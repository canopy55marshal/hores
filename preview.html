
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>赛马游戏逻辑预览 (Lite)</title>
    <style>
        body { background: #1a1a1a; color: #fff; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 0; height: 100vh; justify-content: center; }
        /* 竖屏容器：375x667 (iPhone SE) 或 360x800 (常见安卓) */
        #game-container { 
            width: 375px; 
            height: 667px; 
            border: 2px solid #444; 
            position: relative; 
            background: #000; 
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            overflow: hidden; /* 防止跑出界 */
        }
        #lobby-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: none;
            background: url('backround/1.png') center/cover no-repeat;
            opacity: 1;
            transition: opacity 520ms cubic-bezier(0.22, 1, 0.36, 1);
        }
        .racing-mode #lobby-bg {
            opacity: 0;
        }
        
        /* 顶部信息栏 - 改为 Flex 布局，分两行 */
        #info-panel { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 300px;
            background: rgba(0,0,0,0.6); 
            padding: 6px; 
            box-sizing: border-box;
            z-index: 10;
            display: flex;
            flex-direction: column;
            transition: height 0.3s ease; /* 添加过渡动画 */
            overflow: hidden; /* 防止内容溢出 */
        }

        .season-mini {
            width: 160px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(0,0,0,0.18);
            padding: 6px 8px;
            box-sizing: border-box;
            text-align: right;
        }
        .season-mini .row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            color: #ecf0f1;
            font-weight: 700;
            margin-bottom: 4px;
        }
        .season-mini .row.top {
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 6px;
            align-items: center;
        }
        .season-mini .row.top .mid {
            text-align: center;
        }
        .season-mini .champ {
            color: #f1c40f;
            font-weight: 900;
            font-size: 11px;
            white-space: nowrap;
        }
        .season-mini .row .season {
            color: #f1c40f;
            font-weight: 800;
        }
        .season-mini .bar {
            height: 6px;
            background: rgba(44, 62, 80, 0.9);
            border-radius: 999px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.08);
        }
        .season-mini .bar > div {
            height: 100%;
            background: linear-gradient(90deg, #f39c12, #f1c40f);
        }
        .season-mini .hint {
            font-size: 10px;
            color: #95a5a6;
            margin-top: 4px;
        }
        .season-mini .trophy-row {
            margin-top: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            color: #ecf0f1;
            font-weight: 800;
            padding: 4px 6px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.10);
            background: rgba(0,0,0,0.10);
            cursor: pointer;
            user-select: none;
        }
        .season-mini .trophy-row .value {
            color: #f1c40f;
            font-weight: 900;
        }
        #trophy-shop-modal {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.86);
            z-index: 110;
            align-items: center;
            justify-content: center;
        }
        .trophy-shop-box {
            width: min(520px, 92%);
            background: #2c3e50;
            border-radius: 12px;
            border: 1px solid #f1c40f;
            box-shadow: 0 0 30px rgba(241, 196, 15, 0.25);
            padding: 14px;
            box-sizing: border-box;
        }
        .trophy-shop-title {
            color: #f1c40f;
            font-weight: 900;
            text-align: center;
            margin: 0 0 8px 0;
            font-size: 18px;
        }
        .trophy-shop-balance {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: #ecf0f1;
            background: rgba(0,0,0,0.14);
            border: 1px solid rgba(255,255,255,0.10);
            border-radius: 10px;
            padding: 8px 10px;
            margin-bottom: 10px;
            box-sizing: border-box;
        }
        .trophy-shop-balance .value {
            color: #2ecc71;
            font-weight: 900;
            font-size: 14px;
        }
        .trophy-shop-items {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }
        .trophy-item {
            background: #34495e;
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 12px;
            padding: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            box-sizing: border-box;
        }
        .trophy-item .left {
            text-align: left;
        }
        .trophy-item .name {
            color: #ecf0f1;
            font-weight: 900;
            font-size: 14px;
            margin-bottom: 2px;
        }
        .trophy-item .desc {
            color: #bdc3c7;
            font-size: 11px;
        }
        .trophy-item .cost {
            color: #f1c40f;
            font-weight: 900;
            font-size: 12px;
            margin-bottom: 6px;
            text-align: right;
        }
        
        /* 比赛模式下的样式折叠 */
        .racing-mode #info-panel {
            display: none;
        }
        .racing-mode #info-panel .stable-container,
        .racing-mode #info-panel .season-panel {
            display: none !important;
        }
        .racing-mode #stable-roster-panel {
            display: none !important;
        }

        /* 玩家资产行 */
        .asset-row {
            display: flex;
            justify-content: space-between;
            color: #f1c40f;
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 5px;
            padding: 0 10px;
            flex-shrink: 0;
            height: 30px; /* 固定高度 */
            align-items: center;
        }

        /* 马厩容器 - 横向滚动 */
        .user-panel {
            background: #2c3e50;
            border-radius: 12px;
            margin: 0 0 6px 0;
            padding: 7px 8px;
            border: 1px solid rgba(52, 152, 219, 0.55);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        .stable-panel {
            border-radius: 12px;
            margin: 0;
            padding: 6px;
            height: 200px;
            border: 1px solid rgba(231, 76, 60, 0.45);
            background: #2c3e50;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.35);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 0;
        }
        .stable-hint {
            height: 20px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.18);
            overflow: hidden;
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 0 6px;
            box-sizing: border-box;
        }
        .stable-hint-text {
            flex: 1;
            min-width: 0;
            font-size: 10px;
            color: #ecf0f1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .shop-chip {
            flex: 0 0 auto;
            font-size: 10px;
            line-height: 16px;
            color: #0b0e11;
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid rgba(241,196,15,0.55);
            background: rgba(241,196,15,0.95);
            white-space: nowrap;
            cursor: pointer;
            user-select: none;
            font-weight: 900;
        }
        .hint-chip {
            flex: 0 0 auto;
            font-size: 10px;
            line-height: 16px;
            color: #ecf0f1;
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(52, 152, 219, 0.15);
            white-space: nowrap;
        }
        .stable-container {
            display: flex;
            align-items: stretch;
            overflow-x: auto;
            gap: 8px;
            flex: 1;
            height: auto;
            margin: 0;
            padding: 0;
            scrollbar-width: none;
            transition: opacity 0.3s;
        }
        .stable-container::-webkit-scrollbar { display: none; }

        /* 马匹名牌卡片 */
        .horse-card {
            flex: 0 0 auto;
            min-width: 284px;
            height: 145px;
            background: #34495e;
            border-radius: 8px;
            padding: 8px;
            display: grid;
            grid-template-columns: 1fr 120px;
            grid-template-rows: 1fr;
            grid-template-areas:
                "skills side";
            border: 1px solid #7f8c8d;
            position: relative;
            box-sizing: border-box;
            gap: 8px;
            overflow: hidden;
            align-items: stretch;
        }

        .card-skills {
            grid-area: skills;
            border-radius: 6px;
            padding: 6px;
            border: 1px solid rgba(46, 204, 113, 0.35);
            background: rgba(46, 204, 113, 0.06);
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 4px;
        }
        .horse-name-input {
            height: 20px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.18);
            background: rgba(0,0,0,0.18);
            color: #ecf0f1;
            font-size: 12px;
            font-weight: bold;
            padding: 0 8px;
            box-sizing: border-box;
            outline: none;
        }
        .horse-name-input:focus {
            border-color: rgba(52, 152, 219, 0.65);
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.18);
        }

        .card-info {
            grid-area: info;
            border-radius: 6px;
            padding: 4px 5px;
            border: 1px solid rgba(241, 196, 15, 0.45);
            background: rgba(241, 196, 15, 0.06);
            display: flex;
            flex-direction: column;
            gap: 1px;
            overflow: hidden;
        }

        .card-image {
            grid-area: image;
            border-radius: 6px;
            border: 1px solid rgba(231, 76, 60, 0.35);
            background: #2c3e50;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            padding-top: 0;
        }
        .card-side {
            grid-area: side;
            border-radius: 10px;
            border: 1px solid rgba(241, 196, 15, 0.4);
            background: #2c3e50;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.35);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
        }
        .card-stats {
            padding: 6px 7px 4px;
            display: flex;
            flex-direction: column;
            gap: 2px;
            flex: 1;
            background: transparent;
            box-sizing: border-box;
        }
        .stat-line {
            display: flex;
            justify-content: space-between;
            gap: 6px;
            font-size: 10px;
            line-height: 14px;
            color: #bdc3c7;
            white-space: nowrap;
        }
        .stat-line strong {
            color: #ecf0f1;
            font-weight: 800;
        }
        .card-portrait {
            border-top: 1px solid rgba(255,255,255,0.1);
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            background: transparent;
        }
        .card-portrait .idle-horse {
            width: 64px;
            height: 64px;
            --idle-scale: 1.35;
        }
        .idle-avatar {
            font-size: 34px;
            transform: translateZ(0) scaleX(-1) scale(1.5);
            opacity: 0.95;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.35));
        }
        .idle-horse {
            width: 68px;
            height: 68px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            --idle-scale: 1.5;
            transform: translateZ(0) scaleX(-1) scale(var(--idle-scale));
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.35));
            backface-visibility: hidden;
            will-change: background-image, transform;
            contain: paint;
            isolation: isolate;
        }
        #codex-panel .idle-horse {
            filter: none;
        }
        .market-idle-horse {
            width: 78px;
            height: 78px;
        }
        #market-panel .idle-horse {
            width: 78px;
            height: 78px;
            --idle-scale: 1.5;
        }
        #market-target-preview,
        #market-my-preview {
            min-height: 124px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: visible;
        }
        #market-target-preview {
            transform: translateX(-12px);
        }
        #market-panel #market-target-preview .idle-horse {
            --idle-scale: 1.22;
        }
        .market-side-preview {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }
        .market-side-name {
            font-size: 12px;
            font-weight: 900;
            max-width: 120px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .market-side-sub {
            font-size: 10px;
            color: #bdc3c7;
            margin-top: -4px;
        }
        .market-chip-preview {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .market-chip-names {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 170px;
        }
        .market-chip-name {
            font-size: 11px;
            font-weight: 900;
            color: #ecf0f1;
            max-width: 90px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-shadow: 0 1px 2px rgba(0,0,0,0.45);
        }
        #market-my-preview .idle-horse {
            width: 54px;
            height: 54px;
            --idle-scale: 1.2;
        }
        #market-my-preview .idle-horse + .idle-horse {
            margin-left: -18px;
        }
        .market-chip-more {
            width: 34px;
            height: 34px;
            border-radius: 999px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-left: -12px;
            background: rgba(0,0,0,0.35);
            border: 1px solid rgba(255,255,255,0.18);
            color: #ecf0f1;
            font-size: 11px;
            font-weight: 900;
            backdrop-filter: blur(2px);
        }
        .idle-horse[data-sprite-set="horse"] {
            --idle-scale: 1.65;
        }
        .idle-horse[data-sprite-set="rare"] {
            --idle-scale: 1.98;
        }
        .idle-horse[data-sprite-set="legendary2"] {
            --idle-scale: 1.32;
        }

        .horse-card .name {
            font-size: 14px;
            line-height: 18px;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            text-align: right;
        }
        .horse-card .life {
            font-size: 10px;
            line-height: 14px;
            color: #bdc3c7;
            white-space: nowrap;
            text-align: right;
        }
        .horse-card .blood {
            font-size: 10px;
            line-height: 14px;
            color: #bdc3c7;
            white-space: nowrap;
            text-align: right;
        }

        /* 选中状态的马匹卡片 */
        .horse-card.selected {
            border: 2px solid #2ecc71;
            box-shadow: 0 0 15px rgba(46, 204, 113, 0.4);
            transform: scale(1.02); /* 稍微减小缩放防止模糊 */
        }

        .horse-card:active {
            transform: scale(0.98);
        }
        
        .horse-card .gene-tags {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-auto-rows: 16px;
            gap: 2px;
            width: 100%;
            flex: 1;
            height: auto;
            box-sizing: border-box;
            border-radius: 4px;
            align-content: start;
            overflow: hidden;
        }

        .gene-tags {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-auto-rows: 24px;
            gap: 6px;
            width: 100%;
            box-sizing: border-box;
            border-radius: 6px;
            align-content: start;
        }
        
        .gene-tag {
            font-size: 9px;
            line-height: 16px;
            padding: 0 1px;
            border-radius: 3px;
            color: #ecf0f1;
            font-weight: normal;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis; /* 增加省略号以防溢出 */
            transform: none;
            cursor: help; /* 增加鼠标手势 */
        }
        .gene-normal { background: #27ae60; color: #fff; } /* 已拥有普通-绿色 */
        .gene-rare { background: #f1c40f; color: #000; box-shadow: 0 0 5px rgba(241, 196, 15, 0.5); font-weight: bold; } /* 已拥有稀有-金色 */
        .gene-epic { background: #9b59b6; color: #fff; box-shadow: 0 0 6px rgba(155, 89, 182, 0.6); font-weight: bold; border: 1px solid #8e44ad; } /* 史诗-紫色 */
        .gene-legend { background: #e74c3c; color: #fff; box-shadow: 0 0 8px rgba(231, 76, 60, 0.8); font-weight: bold; border: 1px solid #c0392b; animation: pulse 2s infinite; } /* 神兽-红色 */
        .gene-locked { background: #2c3e50; color: #555; border: 1px solid #444; } /* 未解锁样式 */
        .gene-active { border: 2px solid #3498db; box-shadow: 0 0 6px rgba(52,152,219,0.6); }
        .gene-just { border: 2px solid #e74c3c !important; box-shadow: 0 0 6px rgba(231, 76, 60, 0.6); }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
            70% { box-shadow: 0 0 0 6px rgba(231, 76, 60, 0); }
            100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0); }
        }


        /* 跑道层容器 */
        #track-container {
            position: absolute;
            top: 300px;
            bottom: 0;
            left: 0;
            width: 100%;
            overflow: hidden; 
            transition: top 0.3s ease; /* 添加过渡动画 */
        }
        
        /* 比赛模式下跑道上移 */
        .racing-mode #track-container {
            top: 0;
        }

        #track-layer {
            position: absolute;
            top: 0;
            left: 0;
            /* 跑道改为横向超长 */
            width: 10000px; 
            height: 100%; 
            background-color: #c6f98b;
            background-image: none;
            overflow: hidden;
        }
        .finish-line {
            position: absolute;
            top: 0;
            height: 100%;
            width: 6px;
            background: rgba(255,255,255,0.95);
            box-shadow: 0 0 10px rgba(255,255,255,0.65);
            z-index: 5;
            pointer-events: none;
        }

        /* 跑道分隔线改为横向 */
        .lane-divider {
            position: absolute;
            left: 0;
            right: 0;
            height: 2px;
            background: rgba(255,255,255,0.3);
            border-top: 1px dashed rgba(255,255,255,0.5);
        }

        .track-marks {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 86;
            overflow: hidden;
        }
        .track-mark {
            position: absolute;
            width: 11px;
            height: 8px;
            opacity: var(--op, 0.40);
            background-image:
                radial-gradient(circle at 34% 42%, rgba(0,0,0,0.42) 0 42%, rgba(0,0,0,0) 44%),
                radial-gradient(circle at 66% 42%, rgba(0,0,0,0.42) 0 42%, rgba(0,0,0,0) 44%),
                radial-gradient(circle at 50% 78%, rgba(0,0,0,0.26) 0 34%, rgba(0,0,0,0) 36%);
            transform: translateZ(0) rotate(var(--rot, 0deg)) scale(var(--s, 1));
            animation: trackMarkFade 2.2s ease-out forwards;
            will-change: opacity, transform;
            backface-visibility: hidden;
        }
        .track-mark.circle {
            width: 5px;
            height: 5px;
            background: rgba(0,0,0,0.14);
            border-radius: 999px;
            background-image: none;
        }
        @keyframes trackMarkFade {
            0% { opacity: var(--op, 0.40); }
            100% { opacity: 0; }
        }

        .horse { 
            position: absolute; 
            width: 120px; 
            height: 120px; 
            /* ... 样式保持不变 ... */
            border: none; 
            background-color: transparent !important;
            
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            display: flex;
            align-items: flex-end; 
            justify-content: center; 
            font-size: 10px; 
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
            z-index: 100; 
            will-change: left, background-image, transform;
            backface-visibility: hidden;
            
            background-image: url('assets/sprites/horse_run/1_horesrun.png'); 
            
            /* 镜像翻转：让马头朝右 */
            --race-scale: 1;
            --race-x: 0px;
            --race-y: 0px;
            transform: translate3d(var(--race-x), var(--race-y), 0) scaleX(-1) scale(var(--race-scale)); 
            transform-origin: center;
        }
        .horse-ghost {
            position: absolute;
            width: 120px;
            height: 120px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            pointer-events: none;
            opacity: 0.35;
            filter: blur(0.6px) brightness(1.15) saturate(1.1);
            z-index: 90;
            --race-scale: 1;
            transform: translateZ(0) scaleX(-1) scale(var(--race-scale));
            transform-origin: center;
            will-change: opacity, transform;
            backface-visibility: hidden;
        }
        .horse-burst {
            position: absolute;
            width: 160px;
            height: 160px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            pointer-events: none;
            opacity: 0.9;
            filter: blur(0.2px) brightness(1.2) saturate(1.25);
            z-index: 95;
            --race-scale: 1;
            transform: translateZ(0) scaleX(-1) scale(var(--race-scale));
            transform-origin: center;
            will-change: opacity, transform, background-image;
            backface-visibility: hidden;
        }
        .horse-jifeng {
            position: absolute;
            width: 170px;
            height: 170px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            pointer-events: none;
            opacity: 0.95;
            filter: brightness(1.05) saturate(1.2);
            z-index: 94;
            --race-scale: 1;
            transform: translateZ(0) scaleX(-1) scale(var(--race-scale));
            transform-origin: center;
            will-change: transform, background-image;
            backface-visibility: hidden;
        }
        .horse-lanying {
            position: absolute;
            width: 170px;
            height: 170px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            pointer-events: none;
            opacity: 0.9;
            filter: brightness(1.05) saturate(1.1);
            z-index: 93;
            --race-scale: 1;
            transform: translateZ(0) scaleX(-1) scale(var(--race-scale));
            transform-origin: center;
            will-change: transform, background-image;
            backface-visibility: hidden;
        }
        .horse-lieyan {
            position: absolute;
            width: 175px;
            height: 175px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            pointer-events: none;
            opacity: 0.92;
            filter: brightness(1.1) saturate(1.2);
            z-index: 92;
            --race-scale: 1;
            transform: translateZ(0) scaleX(-1) scale(var(--race-scale));
            transform-origin: center;
            will-change: transform, background-image;
            backface-visibility: hidden;
        }
        .horse-dust {
            position: absolute;
            width: 110px;
            height: 70px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            pointer-events: none;
            opacity: 0.9;
            filter: brightness(1.02) saturate(1.05);
            z-index: 85;
            --race-scale: 1;
            transform: translateZ(0) scaleX(1) scale(var(--race-scale));
            transform-origin: center;
            will-change: transform, opacity, background-image, left, top;
            backface-visibility: hidden;
        }
        
        /* 修正文字方向：因为父元素翻转了，文字也会翻转，需要把文字翻转回来 */
        /* 但由于我们把文字直接写在 .horse 里，处理起来比较麻烦 */
        /* 更好的做法是把文字单独放一个子元素，或者不翻转父元素，而是用 scaleX(-1) 翻转背景图 */
        /* 不过 background-image 不支持直接 scaleX，所以必须翻转容器 */
        /* 我们给文字加一个反向翻转 */


        /* 移除之前的 CSS 绘制 */
        .horse::before { content: none; }
        .horse::after { content: none; }

        /* 定义动画类 - 我们用 JS 动态切换背景图来实现序列帧，因为图片是独立的 png */
        /* 或者使用 CSS keyframes 如果图片拼在一起 */


        /* UI 操作层 */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; }
        #ui-layer * { pointer-events: auto; }

        #trade-list .trade-team-item {
            padding: 10px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
            transition: background 160ms ease, box-shadow 160ms ease, border-color 160ms ease, transform 160ms ease;
        }
        #trade-list .trade-team-item:hover {
            background: rgba(52, 152, 219, 0.10);
        }
        #trade-list .trade-team-item.selected {
            background: rgba(46, 204, 113, 0.14);
            border: 1px solid rgba(46, 204, 113, 0.65);
            border-bottom: 1px solid rgba(46, 204, 113, 0.65);
            border-radius: 8px;
            margin: 6px;
            box-shadow: 0 10px 24px rgba(0,0,0,0.35), 0 0 0 2px rgba(46, 204, 113, 0.16);
            transform: translateY(-1px);
        }
        #trade-list .trade-team-item.selected + .trade-team-item {
            border-top: 1px solid #333;
        }
        #trade-list .trade-select-indicator {
            font-size: 11px;
            color: #2ecc71;
            font-weight: 900;
            opacity: 0;
            transform: translateX(6px);
            transition: opacity 180ms ease, transform 180ms ease;
            letter-spacing: 0.5px;
        }
        #trade-list .trade-team-item.selected .trade-select-indicator {
            opacity: 1;
            transform: translateX(0);
        }
        
        /* 结算面板 */
        #result-panel {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 50;
            background: rgba(0,0,0,0.6);
        }
        .result-box {
            width: 80%;
            background: #2c3e50;
            border: 1px solid #7f8c8d;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
        }
        .result-title {
            font-size: 20px;
            margin-bottom: 8px;
            color: #f1c40f;
        }
        .result-desc {
            font-size: 14px;
            color: #ecf0f1;
            margin-bottom: 12px;
        }
        .result-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .btn-small {
            padding: 8px 12px;
            font-size: 14px;
            width: auto;
        }
        .countdown {
            margin-top: 8px;
            font-size: 12px;
            color: #bdc3c7;
        }
        /* 底部按钮区 */
        .panel { 
            position: absolute; 
            bottom: 50px; 
            left: 50%; 
            transform: translateX(-50%); 
            text-align: center; 
            width: 100%;
        }

        #lobby-panel {
            left: 0;
            right: 0;
            top: auto;
            bottom: 14px;
            transform: none;
            width: 100%;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            padding: 0 16px;
            box-sizing: border-box;
            align-content: end;
            overflow: hidden;
            z-index: 15;
        }
        #lobby-panel .lobby-btn {
            width: 100%;
            margin: 0;
            padding: 0;
            border-radius: 14px;
            aspect-ratio: 1 / 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 16px;
            line-height: 1.1;
        }
        #lobby-panel .lobby-icon {
            width: 34px;
            height: 34px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
        }
        #lobby-panel .lobby-text {
            font-size: 14px;
            font-weight: 800;
            color: #ecf0f1;
        }

        #stable-roster-panel {
            position: absolute;
            left: 0;
            right: 0;
            top: 300px;
            bottom: 112px;
            padding: 10px 12px;
            box-sizing: border-box;
            z-index: 12;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .roster-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 2px;
        }
        .roster-cap {
            font-size: 12px;
            font-weight: 800;
            color: #ecf0f1;
        }
        .roster-grid {
            flex: 1;
            border-radius: 14px;
            border: 1px solid rgba(255,255,255,0.14);
            background: rgba(0,0,0,0.12);
            padding: 10px 74px 10px 10px;
            box-sizing: border-box;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-auto-rows: 92px;
            gap: 12px;
            align-content: start;
            overflow: hidden;
            scrollbar-width: none;
        }
        .roster-grid::-webkit-scrollbar { display: none; }
        .roster-item {
            width: 100%;
            height: 92px;
            border-radius: 12px;
            background: rgba(44, 62, 80, 0.82);
            border: 1px solid rgba(255,255,255,0.14);
            box-shadow: 0 4px 10px rgba(0,0,0,0.25);
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            box-sizing: border-box;
            cursor: pointer;
            user-select: none;
        }
        .roster-item.empty {
            cursor: default;
            background: rgba(44, 62, 80, 0.35);
            border-style: dashed;
            opacity: 0.7;
        }
        .roster-item.selected {
            border: 2px solid #2ecc71;
            box-shadow: 0 0 12px rgba(46, 204, 113, 0.35);
        }
        .roster-item .idle-horse {
            width: 58px;
            height: 58px;
            --idle-scale: 1.35;
        }
        .roster-meta {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .roster-name {
            font-size: 12px;
            font-weight: 800;
            color: #ecf0f1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .roster-sub {
            font-size: 10px;
            color: #bdc3c7;
            white-space: nowrap;
        }
        .roster-actions {
            position: absolute;
            right: 10px;
            top: 92px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 2;
        }
        .roster-actions .btn {
            width: 58px;
            margin: 0;
            padding: 10px 0;
            font-size: 12px;
            border-radius: 12px;
            line-height: 1.1;
        }
        .roster-actions .btn .sub {
            display: block;
            font-size: 10px;
            color: rgba(255,255,255,0.82);
            font-weight: 700;
            margin-top: 2px;
        }

        #horse-detail-wrap .horse-card {
            min-width: 100%;
        }
        
        .btn { 
            display: block;
            width: 80%;
            margin: 10px auto;
            padding: 15px 0; 
            cursor: pointer; 
            font-size: 18px; 
            border: none; 
            color: #fff; 
            border-radius: 8px;
            font-weight: bold;
        }
        .btn-green { background: #27ae60; box-shadow: 0 4px #219150; }
        .btn-green:active { transform: translateY(2px); box-shadow: 0 2px #219150; }
        
        .btn-blue { background: #2980b9; box-shadow: 0 4px #2c3e50; }
        .btn-blue:active { transform: translateY(2px); box-shadow: 0 2px #2c3e50; }
        .btn-orange { background: #ff7a00; box-shadow: 0 4px #cc5a00; }
        .btn-orange:active { transform: translateY(2px); box-shadow: 0 2px #cc5a00; }

        /* 技能说明弹窗 */
        #skill-modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 40;
        }
        .skill-modal-box {
            width: 80%;
            max-width: 320px;
            background: #2c3e50;
            border-radius: 10px;
            padding: 16px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
            color: #ecf0f1;
            text-align: center;
            border: 1px solid #7f8c8d;
        }
        .skill-title { font-weight: bold; font-size: 18px; margin-bottom: 8px; color: #f1c40f; }
        .skill-desc { font-size: 13px; color: #bdc3c7; margin-bottom: 12px; line-height: 1.5; }

        /* 培育界面 (模拟弹窗) */
        #breed-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* 修正图片路径：Web服务器根目录在 e:\hores，所以是 assets/... */
            background-image: url('assets/bg/breed_bg.png'); 
            background-size: cover;
            background-position: center;
            display: none;
            z-index: 30;
            flex-direction: column;
            justify-content: flex-end; 
            padding-bottom: 50px;
        }
        
        #breed-panel::before {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.4); /* 遮罩层，让文字更清晰 */
            z-index: -1;
        }

        /* 培育界面样式补全 */
        .breed-info {
            position: relative;
            background: rgba(255,255,255,0.9);
            color: #333;
            margin: 20px;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        /* 洗练界面 */
        #reforge-panel {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            z-index: 40;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* 选秀界面 */
        #draft-panel {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 60;
            display: none; align-items: center; justify-content: center; flex-direction: column;
        }
        .draft-container {
            width: min(520px, 92%);
            max-height: 92%;
            background: #2c3e50;
            border-radius: 12px;
            padding: 14px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            text-align: center; border: 1px solid #f1c40f; box-shadow: 0 0 30px rgba(241, 196, 15, 0.3);
            box-sizing: border-box;
        }
        #draft-panel .draft-container > h2 { margin: 0 0 2px 0; }
        #draft-status {
            text-align: left;
            background: rgba(0,0,0,0.14);
            border: 1px solid rgba(255,255,255,0.10);
            border-radius: 12px;
            padding: 10px;
            box-sizing: border-box;
        }
        #draft-result.draft-result {
            display: none;
            flex: 1;
            min-height: 0;
            margin: 0;
            padding: 12px;
            background: #34495e;
            border-radius: 12px;
            overflow-y: auto;
            scrollbar-width: none;
        }
        #draft-result.draft-result::-webkit-scrollbar { display: none; }
        .draft-seed-line {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 6px;
        }
        .draft-seed-line .seed {
            color: #e74c3c;
            font-weight: 900;
            font-size: 18px;
        }
        .draft-pill-row {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: flex-start;
            margin-top: 8px;
        }
        .draft-pill {
            padding: 4px 8px;
            border-radius: 999px;
            border: 1px solid rgba(255,255,255,0.14);
            background: rgba(0,0,0,0.12);
            white-space: nowrap;
            font-size: 11px;
            color: #ecf0f1;
        }
        .draft-pill.is-top4 {
            border-color: rgba(241,196,15,0.42);
            background: rgba(241,196,15,0.16);
        }
        .draft-map {
            margin-top: 8px;
        }
        .draft-map summary {
            cursor: pointer;
            user-select: none;
            font-size: 11px;
            color: #95a5a6;
            list-style: none;
        }
        .draft-map summary::-webkit-details-marker { display: none; }
        .draft-map-grid {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            max-height: 120px;
            overflow: auto;
            padding-right: 4px;
            scrollbar-width: none;
        }
        .draft-map-grid::-webkit-scrollbar { display: none; }

        .draft-info {
            margin-top: 10px;
            background: rgba(0,0,0,0.14);
            border: 1px solid rgba(255,255,255,0.10);
            border-radius: 12px;
            padding: 10px;
            box-sizing: border-box;
        }
        .draft-info-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            align-items: start;
        }
        .draft-kv {
            display: grid;
            gap: 6px;
            align-content: start;
        }
        .draft-kv .label {
            font-size: 11px;
            color: #95a5a6;
        }
        .draft-kv .value {
            font-size: 18px;
            font-weight: 900;
            color: #ecf0f1;
        }
        .draft-kv .value strong {
            color: #f1c40f;
        }
        .draft-selected {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }
        #draft-selected-preview {
            width: 140px;
            height: 86px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(0,0,0,0.10);
            overflow: hidden;
        }
        #draft-selected-preview .idle-horse {
            width: 86px;
            height: 86px;
            --idle-scale: 1.65;
        }
        .draft-selected .idle-horse {
            width: 74px;
            height: 74px;
            --idle-scale: 1.4;
        }
        .draft-selected .quality {
            font-size: 12px;
            font-weight: 900;
            color: #bdc3c7;
        }
        .draft-skill-title {
            margin-top: 10px;
            font-size: 11px;
            color: #95a5a6;
            text-align: left;
        }
        .draft-skill-tags {
            margin-top: 6px;
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-auto-rows: 18px;
            gap: 4px;
            width: 100%;
            box-sizing: border-box;
            min-height: 40px;
        }
        #draft-skill-pool:empty {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #95a5a6;
            font-size: 12px;
        }
        #draft-skill-pool:empty::before {
            content: '技能池预留区域';
        }

        #codex-panel { z-index: 120; }
        #draft-actions {
            width: 100%;
            display: none;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            padding: 0 12px 6px;
            box-sizing: border-box;
            margin-top: 6px;
        }
        #draft-actions .draft-action-btn {
            width: 100%;
            margin: 0;
            padding: 0;
            border-radius: 14px;
            aspect-ratio: 1 / 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 16px;
            line-height: 1.1;
        }
        #draft-actions .lobby-icon {
            width: 34px;
            height: 34px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
        }
        #draft-actions .lobby-text {
            font-size: 14px;
            font-weight: 800;
            color: #ecf0f1;
        }

        .reforge-container {
            width: 90%;
            background: #2c3e50;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 1px solid #7f8c8d;
        }

        .reforge-row {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 12px;
        }

        .reforge-box {
            width: 50%;
            background: #34495e;
            padding: 10px;
            border-radius: 5px;
            min-height: 230px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .reforge-title {
            color: #bdc3c7;
            font-size: 14px;
            margin-bottom: 10px;
            text-align: center;
            border-bottom: 1px solid #7f8c8d;
            padding-bottom: 5px;
        }

        .reforge-actions {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
        }

        .reforge-split {
            display: flex;
            gap: 10px;
            flex: 1;
            overflow: hidden;
        }
        .reforge-skill-list {
            width: 56px;
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow: hidden;
        }
        .reforge-skill-item {
            width: 100%;
            height: 26px;
            line-height: 26px;
            padding: 0 4px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
        }
        .reforge-skill-item.is-selected {
            outline: 2px solid rgba(46, 204, 113, 0.95);
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.35);
        }
        .reforge-skill-detail {
            flex: 1;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.10);
            background: rgba(0,0,0,0.14);
            padding: 10px;
            box-sizing: border-box;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .reforge-effect-title {
            color: #ecf0f1;
            font-weight: bold;
            font-size: 14px;
            line-height: 18px;
        }
        .reforge-effect-badge {
            color: #f1c40f;
            font-size: 12px;
            line-height: 16px;
        }
        .reforge-effect-text {
            color: #bdc3c7;
            font-size: 12px;
            line-height: 16px;
            overflow: hidden;
        }
        .reforge-effect-placeholder {
            color: #7f8c8d;
            font-size: 13px;
            line-height: 18px;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        /* 玩家头像与荣誉框 */
        .avatar-wrapper {
            position: relative;
            width: 40px; height: 40px;
            margin-right: 10px;
            flex-shrink: 0;
        }
        .avatar {
            width: 100%; height: 100%;
            background: #95a5a6;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px;
            border: 2px solid #bdc3c7;
            box-sizing: border-box;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            cursor: pointer;
        }
        .avatar.has-img { color: transparent; }
        .avatar-action {
            background: none;
            border: none;
            color: #2ecc71;
            font-weight: bold;
            cursor: pointer;
            font-size: 12px;
            padding: 0;
        }
        #avatar-auth-modal,
        #avatar-picker-modal {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.75);
            z-index: 110;
        }
        .avatar-modal-box {
            width: 86%;
            max-width: 320px;
            background: #2c3e50;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.12);
            box-shadow: 0 8px 20px rgba(0,0,0,0.35);
            padding: 14px;
            box-sizing: border-box;
        }
        .avatar-modal-title {
            font-weight: bold;
            font-size: 16px;
            color: #ecf0f1;
            margin-bottom: 8px;
        }
        .avatar-modal-desc {
            font-size: 12px;
            color: #bdc3c7;
            line-height: 16px;
            margin-bottom: 12px;
        }
        .avatar-modal-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .avatar-picker-list {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            max-height: 260px;
            overflow-y: auto;
            padding: 4px;
            box-sizing: border-box;
            margin-bottom: 12px;
        }
        .avatar-pick {
            width: 100%;
            aspect-ratio: 1 / 1;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(0,0,0,0.15);
            overflow: hidden;
            cursor: pointer;
            padding: 0;
        }
        .avatar-pick img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }
        /* 冠军金框 */
        .avatar-frame-gold {
            position: absolute;
            top: -5px; left: -5px;
            width: 50px; height: 50px;
            border: 3px solid #f1c40f;
            border-radius: 50%;
            box-shadow: 0 0 10px #f1c40f, inset 0 0 5px #f1c40f;
            pointer-events: none;
            z-index: 2;
        }
        /* 荣誉皇冠 */
        .honor-crown {
            position: absolute;
            top: -12px; left: 50%;
            transform: translateX(-50%) rotate(-10deg);
            font-size: 18px;
            text-shadow: 0 2px 2px rgba(0,0,0,0.5);
            z-index: 3;
            animation: floatCrown 2s ease-in-out infinite;
        }
        @keyframes floatCrown {
            0%, 100% { transform: translateX(-50%) rotate(-10deg) translateY(0); }
            50% { transform: translateX(-50%) rotate(-10deg) translateY(-3px); }
        }
        /* 比赛中马匹头顶信息 */
        .horse-name-tag {
            position: absolute;
            background: rgba(0,0,0,0.5); /* 稍微降低透明度 */
            padding: 2px 6px;
            border-radius: 10px; /* 胶囊形状 */
            color: #fff;
            font-size: 10px;
            text-align: center;
            pointer-events: none; 
            z-index: 101;
            white-space: nowrap;
            display: flex;
            flex-direction: row; /* 改为横向排列 */
            align-items: center;
            gap: 4px; /* 名字和技能之间的间距 */
            /* 调整位置：
               - translate(-50%, -100%)：基准点位于元素底部中心
               - top: 0：定位到马匹容器的顶部
               - z-index: 确保在马匹上方，但需要注意层级关系
            */
            transform: translate(-50%, -80%); /* 向上偏移，位于头顶 */
            margin-top: 0; 
            z-index: 200; /* 提高层级，防止被上方跑道的马匹遮挡 */
        }
        .horse-name-tag .name-row {
            font-weight: bold;
            text-shadow: 0 1px 1px #000;
        }
        .horse-name-tag.is-player .name-row {
            color: #f1c40f;
            font-weight: bold;
        }
        .horse-name-tag .skill-row {
            display: flex;
            gap: 1px;
            justify-content: center;
        }
        .mini-gene-tag {
            font-size: 8px; /* 进一步减小字体 */
            padding: 0 2px;
            border-radius: 2px;
            line-height: 1.2;
        }
        #scene-transition {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 95;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.92);
            opacity: 0;
            transition: opacity 650ms cubic-bezier(0.22, 1, 0.36, 1), background 300ms ease;
            pointer-events: auto;
        }
        #scene-transition.fade-black {
            background: rgba(0,0,0,1);
        }
        #scene-transition.show {
            opacity: 1;
        }
        .scene-transition-box {
            width: min(320px, 86%);
            background: rgba(44, 62, 80, 0.95);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 14px;
            padding: 14px 14px 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.55);
            text-align: center;
            transition: opacity 420ms cubic-bezier(0.22, 1, 0.36, 1), transform 420ms cubic-bezier(0.22, 1, 0.36, 1);
        }
        #scene-transition.fade-black .scene-transition-box {
            opacity: 0;
            transform: translateY(10px) scale(0.98);
        }
        .scene-transition-title {
            font-weight: 900;
            color: #f1c40f;
            font-size: 16px;
            margin-bottom: 6px;
        }
        .scene-transition-sub {
            font-size: 12px;
            color: #bdc3c7;
            margin-bottom: 10px;
        }
        .scene-transition-bar {
            height: 8px;
            border-radius: 999px;
            background: rgba(0,0,0,0.25);
            border: 1px solid rgba(255,255,255,0.08);
            overflow: hidden;
        }
        .scene-transition-bar > div {
            height: 100%;
            width: 40%;
            background: linear-gradient(90deg, #2ecc71, #f1c40f);
            border-radius: 999px;
            animation: sceneLoad 900ms ease-in-out infinite;
        }
        @keyframes sceneLoad {
            0% { transform: translateX(-120%); }
            100% { transform: translateX(280%); }
        }
    </style>
</head>
<body>
    <h1>赛马游戏逻辑预览 (Lite)</h1>
    <div id="game-container">
        <div id="lobby-bg"></div>
        <div id="track-container">
            <div id="track-layer"></div>
        </div>
        <div id="ui-layer">
            <div id="info-panel"></div>
            <div id="stable-roster-panel" style="display:none;"></div>
            <div id="lobby-panel" class="panel">
                <button id="btn-primary-action" class="btn btn-blue lobby-btn" onclick="game.startRace()">
                    <div class="lobby-icon">🏠</div>
                    <div class="lobby-text">开始比赛</div>
                </button>
                <button class="btn btn-blue lobby-btn" onclick="game.openBreed()">
                    <div class="lobby-icon">⬆️</div>
                    <div class="lobby-text">基因培育</div>
                </button>
                <button class="btn btn-blue lobby-btn" onclick="game.openReforge()">
                    <div class="lobby-icon">💎</div>
                    <div class="lobby-text">技能洗练</div>
                </button>
                <button class="btn btn-blue lobby-btn" onclick="game.openCodex()">
                    <div class="lobby-icon">➕</div>
                    <div class="lobby-text">造型图鉴</div>
                </button>
            </div>
            <div id="status-label" class="panel" style="top: 40%; display: none;"></div>
            <div id="scene-transition">
                <div class="scene-transition-box">
                    <div class="scene-transition-title" id="scene-transition-title">加载地图</div>
                    <div class="scene-transition-sub" id="scene-transition-sub">正在准备赛道...</div>
                    <div class="scene-transition-bar"><div></div></div>
                </div>
            </div>
            <div id="result-panel">
                <div class="result-box">
                    <div id="result-title" class="result-title"></div>
                    <div id="result-desc" class="result-desc"></div>
                    <div class="result-actions">
                        <button id="btn-back-lobby" class="btn btn-green btn-small">返回大厅</button>
                    </div>
                    <div id="result-countdown" class="countdown"></div>
                </div>
            </div>
            <div id="skill-modal">
                <div class="skill-modal-box">
                    <div id="skill-title" class="skill-title"></div>
                    <div id="skill-desc" class="skill-desc"></div>
                    <button class="btn btn-green btn-small" style="width:60%; font-size:14px;" onclick="game.closeSkillModal()">关闭</button>
                </div>
            </div>
            <div id="codex-panel" style="display:none; position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.88); z-index:65; align-items:center; justify-content:center;">
                <div style="width:90%; background:#2c3e50; border-radius:12px; padding:15px; border:1px solid #f1c40f; box-shadow:0 0 20px rgba(0,0,0,0.6);">
                    <h3 style="color:#f1c40f; text-align:center; margin-top:0;">📖 造型图鉴</h3>
                    <div id="codex-list" style="display:flex; flex-wrap:wrap; gap:10px; justify-content:center; max-height:420px; overflow-y:auto;"></div>
                    <button class="btn btn-blue" style="background:#7f8c8d; margin-top:10px; width:100%;" onclick="game.closeCodex()">关闭</button>
                </div>
            </div>
            <div id="avatar-auth-modal">
                <div class="avatar-modal-box">
                    <div class="avatar-modal-title">获取头像授权</div>
                    <div class="avatar-modal-desc">登录后可获取微信头像用于展示。当前测试从本地目录加载：E:\\hores\\Test Friend Avatar</div>
                    <div class="avatar-modal-actions">
                        <button class="btn btn-green btn-small" style="width:45%;" onclick="game.grantAvatarConsent()">同意</button>
                        <button class="btn btn-blue btn-small" style="width:45%; background:#7f8c8d; box-shadow:0 4px #666;" onclick="game.denyAvatarConsent()">拒绝</button>
                    </div>
                </div>
            </div>
            <div id="avatar-picker-modal">
                <div class="avatar-modal-box">
                    <div class="avatar-modal-title">更换头像</div>
                    <div class="avatar-modal-desc">从本地目录选择一张图片作为头像（可在文件夹里替换/新增）。</div>
                    <div id="avatar-picker-list" class="avatar-picker-list"></div>
                    <div class="avatar-modal-actions">
                        <button class="btn btn-blue btn-small" style="width:60%; background:#7f8c8d; box-shadow:0 4px #666;" onclick="game.closeAvatarPicker()">关闭</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 培育界面 -->
        <div id="breed-panel">
            <div class="breed-info">
                <h2>马厩培育中心</h2>
                <p>消耗 500 积分和父本 10 点寿命，为您当前的赛马寻找配偶。</p>
                <p id="breed-result" style="font-weight:bold; color:#e67e22;"></p>
                <button class="btn btn-green" onclick="game.confirmBreed()">开始培育</button>
                <button class="btn btn-blue" style="background:#7f8c8d" onclick="game.closeBreed()">返回大厅</button>
            </div>
        </div>

        <!-- 洗练界面 -->
        <div id="reforge-panel">
            <div class="reforge-container">
                <h2 style="text-align:center; margin-top:0; color:#e056fd">技能洗练中心</h2>
                <p style="text-align:center; font-size:12px; color:#aaa">技能槽中每个稀有技能增加基础速度 3%</p>
                
                <div class="reforge-row">
                    <div class="reforge-box">
                        <div class="reforge-title" style="font-size:16px;">当前技能</div>
                        <div class="reforge-split">
                            <div id="reforge-current-list" class="reforge-skill-list"></div>
                            <div id="reforge-current-detail" class="reforge-skill-detail">
                                <div class="reforge-effect-placeholder">选择左侧技能查看效果</div>
                            </div>
                        </div>
                    </div>
                    <div class="reforge-box">
                        <div class="reforge-title" style="font-size:16px;">洗练预览</div>
                        <div class="reforge-split">
                            <div id="reforge-new-list" class="reforge-skill-list"></div>
                            <div id="reforge-new-detail" class="reforge-skill-detail">
                                <div class="reforge-effect-placeholder">点击洗练生成</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="reforge-actions">
                    <button id="btn-do-reforge" class="btn btn-blue" style="width:40%; background:#8e44ad; font-size:14px;" onclick="game.doReforge()">洗练</button>
                    <button id="btn-save-reforge" class="btn btn-green" style="width:40%; display:none; font-size:14px;" onclick="game.saveReforge()">保存结果</button>
                    <button id="btn-discard-reforge" class="btn btn-blue" style="width:40%; display:none; background:#7f8c8d; font-size:14px;" onclick="game.discardReforge()">放弃</button>
                </div>
                <button class="btn btn-blue" style="background:#7f8c8d; margin-top:10px;" onclick="game.closeReforge()">关闭</button>
            </div>
        </div>

        <!-- 交易市场界面 -->
        <div id="trade-panel" style="display:none; position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:70; flex-direction:column; align-items:center; justify-content:center;">
            <div style="width:90%; background:#2c3e50; border-radius:12px; padding:15px; border:1px solid #f39c12; box-shadow:0 0 20px rgba(243,156,18,0.3);">
                <h3 style="color:#f1c40f; text-align:center; margin-top:0;">🤝 选秀权交易市场</h3>
                
                <div style="display:flex; justify-content:space-between; margin-bottom:10px; padding:10px; background:#34495e; border-radius:6px;">
                    <div style="text-align:center; width:45%;">
                        <div style="color:#95a5a6; font-size:12px;">我的资产</div>
                        <div style="color:#2ecc71; font-weight:bold;">💰 <span id="trade-my-points">0</span></div>
                        <div style="color:#e67e22; font-weight:bold; margin-top:5px;">🎫 <span id="trade-my-tier">第 - 档</span></div>
                    </div>
                    <div style="display:flex; align-items:center; color:#bdc3c7;">VS</div>
                    <div style="text-align:center; width:45%;">
                        <div style="color:#95a5a6; font-size:12px;">目标</div>
                        <div style="color:#3498db; font-weight:bold; margin-top:15px;">🏁 <span id="trade-target-tier">选择队伍</span></div>
                    </div>
                </div>

                <div id="trade-list" style="height:150px; overflow-y:auto; background:#222; border-radius:6px; margin-bottom:10px;">
                    <!-- JS 生成列表 -->
                </div>

                <div id="trade-action-area" style="display:none; text-align:center;">
                    <div style="color:#ecf0f1; font-size:12px; margin-bottom:5px;">出价: <span id="trade-offer-val" style="color:#f1c40f;">0</span> 积分 + 我的选秀权</div>
                    <input type="range" id="trade-slider" min="0" max="10000" step="100" style="width:80%;" oninput="game.updateTradeCalc()">
                    <div id="trade-msg" style="font-size:12px; height:20px; margin:5px 0;"></div>
                    <button class="btn btn-green" style="width:100%; margin-top:5px;" onclick="game.executeTrade()">确认交易</button>
                </div>

                <button class="btn btn-blue" style="background:#7f8c8d; margin-top:10px; width:100%;" onclick="game.closeTrade()">返回选秀大会</button>
            </div>
        </div>

        <!-- 选秀界面 -->
        <div id="draft-panel">
            <div class="draft-container">
                <h2 style="color:#f1c40f;">赛季选秀大会</h2>
                <div id="draft-status"></div>
                
                <!-- 新增交易入口 -->
                <button id="btn-open-trade" class="btn btn-blue" style="background:#8e44ad; margin-bottom:10px; box-shadow: 0 4px #6c3483;" onclick="game.openTrade()">🤝 交易选秀权</button>

                <div id="draft-result" class="draft-result">
                    <div style="font-size:18px; color:#2ecc71; margin-bottom:10px;">🎉 获得 <span id="draft-pick-no" style="color:#f1c40f; font-weight:bold;"></span> 顺位选择权</div>
                    <div class="draft-info">
                        <div class="draft-info-row">
                            <div class="draft-kv">
                                <div class="label">你的种子</div>
                                <div class="value"><strong id="draft-my-seed-val">-</strong></div>
                                <div class="label">最终获得的顺位</div>
                                <div class="value"><strong id="draft-final-pick-val">-</strong></div>
                            </div>
                            <div class="draft-selected">
                                <div id="draft-selected-preview"></div>
                                <div class="quality">稀有等级：<span id="draft-selected-quality">未选择</span></div>
                            </div>
                        </div>
                        <div class="draft-skill-title">对应技能池</div>
                        <div id="draft-skill-pool" class="draft-skill-tags"></div>
                    </div>
                    <div id="draft-pool-container" style="display:flex; flex-wrap:wrap; justify-content:center; gap:10px; margin-top:10px;"></div>
                </div>
                <div id="draft-actions">
                    <button id="btn-close-draft" class="btn btn-blue draft-action-btn" style="display:none;" onclick="game.closeDraft()">
                        <div class="lobby-icon">🏁</div>
                        <div class="lobby-text">开启赛季</div>
                    </button>
                    <button id="btn-trade-new-horse" class="btn btn-blue draft-action-btn" style="display:none; background:#e67e22;" onclick="game.openHorseTrade()">
                        <div class="lobby-icon">💰</div>
                        <div class="lobby-text">出售新马</div>
                    </button>
                    <button id="btn-market-trade" class="btn btn-blue draft-action-btn" style="display:none; background:#9b59b6;" onclick="game.openMarket()">
                        <div class="lobby-icon">🔄</div>
                        <div class="lobby-text">交易市场</div>
                    </button>
                    <button id="btn-draft-codex" class="btn btn-blue draft-action-btn" style="display:none; background:#2980b9;" onclick="game.openCodex()">
                        <div class="lobby-icon">➕</div>
                        <div class="lobby-text">造型图鉴</div>
                    </button>
                </div>
                <button id="btn-start-draft" class="btn btn-green" onclick="game.startDraft()">开始抽签</button>
            </div>
        </div>
        
        <!-- Ticket Menu Modal -->
        <div id="ticket-modal" style="display:none; position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:100; align-items:center; justify-content:center;">
            <div style="background:#2c3e50; padding:20px; border-radius:10px; width:80%; max-width:300px; text-align:center; border:2px solid #f39c12; box-shadow: 0 0 20px rgba(0,0,0,0.8);">
                <h3 style="color:#f1c40f; margin-top:0; border-bottom:1px solid #7f8c8d; padding-bottom:10px;">🎫 获取门票</h3>
                <p style="color:#bdc3c7; font-size:14px; margin:20px 0;">当前拥有: <span id="ticket-modal-count" style="color:#2ecc71; font-weight:bold; font-size:18px;">0</span> 张</p>
                
                <button class="btn btn-blue" onclick="game.buyTicketWithPoints()">
                    💰 消耗积分 (200分/张)
                </button>
                
                <button id="btn-watch-ad-modal" class="btn btn-green" onclick="game.watchAdForTicket()" style="margin-top:10px;">
                    📺 观看广告 (免费+5)
                </button>
                
                <button class="btn" style="margin-top:20px; background:#95a5a6; padding:10px; font-size:14px;" onclick="game.closeTicketMenu()">关闭</button>
            </div>
        </div>

        <div id="trophy-shop-modal">
            <div class="trophy-shop-box">
                <div class="trophy-shop-title">🏆 稀有马兑换商城</div>
                <div class="trophy-shop-balance">
                    <div>奖杯积分（赛季第一次数）</div>
                    <div class="value" id="trophy-shop-balance">0</div>
                </div>
                <div class="trophy-shop-items" id="trophy-shop-items"></div>
                <button class="btn btn-blue" style="background:#7f8c8d; width:100%; margin-top:12px;" onclick="game.closeTrophyShop()">关闭</button>
            </div>
        </div>

        <!-- 球员交易市场界面 -->
        <div id="market-panel" style="display:none; position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index:90; flex-direction:column; align-items:center;">
             <div style="width:100%; height:40px; background:#2c3e50; display:flex; align-items:center; padding:0 10px; box-sizing:border-box; justify-content:space-between;">
                 <span style="color:#f1c40f; font-weight:bold;">🔄 自由市场</span>
                 <button class="btn btn-blue btn-small" style="background:#e74c3c; width:auto; padding:5px 10px;" onclick="game.closeMarket()">关闭</button>
             </div>
             
             <div style="flex:1; width:100%; overflow-y:auto; padding:10px; box-sizing:border-box;">
                 <!-- 交易区布局：上部分为 AI 马列表，下部分为我的筹码 -->
                 
                 <div style="margin-bottom:10px;">
                     <div style="color:#bdc3c7; font-size:12px; margin-bottom:5px;">🎯 目标 (AI 的马)</div>
                     <div id="market-ai-list" style="display:flex; overflow-x:auto; gap:10px; padding-bottom:10px;"></div>
                 </div>
                 
                 <div style="margin-bottom:10px; border-top:1px solid #444; padding-top:10px;">
                     <div style="color:#bdc3c7; font-size:12px; margin-bottom:5px;">💰 我的筹码 (勾选马匹 + 积分)</div>
                     <div id="market-my-list" style="display:flex; overflow-x:auto; gap:10px; padding-bottom:10px;"></div>
                 </div>
                 
                 <!-- 交易计算区 -->
                 <div style="background:#34495e; padding:15px; border-radius:8px; text-align:center;">
                     <div style="display:flex; justify-content:space-around; align-items:center; margin-bottom:15px;">
                         <div style="text-align:center;">
                             <div id="market-target-preview"></div>
                             <div style="font-size:12px; color:#95a5a6;">对方价值</div>
                             <div id="market-target-val" style="font-size:24px; color:#e74c3c; font-weight:bold;">0</div>
                         </div>
                         <div style="font-size:20px; color:#bdc3c7;">VS</div>
                         <div style="text-align:center;">
                             <div id="market-my-preview"></div>
                             <div style="font-size:12px; color:#95a5a6;">我方价值</div>
                             <div id="market-my-val" style="font-size:24px; color:#2ecc71; font-weight:bold;">0</div>
                         </div>
                     </div>
                     
                     <div style="margin-bottom:10px;">
                        <span style="color:#ecf0f1; font-size:12px;">追加积分: <span id="market-points-val" style="color:#f1c40f;">0</span></span>
                        <input type="range" id="market-points-slider" min="0" max="10000" step="100" style="width:100%;" oninput="game.updateMarketCalc()">
                     </div>
                     
                     <div id="market-msg" style="font-size:12px; margin-bottom:10px; height:20px;"></div>
                     
                     <button class="btn btn-green" onclick="game.executeMarketTrade()">🤝 确认交易</button>
                 </div>
             </div>
        </div>
        
        <!-- 马匹交易确认弹窗 -->
        <div id="horse-trade-modal" style="display:none; position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:80; flex-direction:column; align-items:center; justify-content:center;">
             <div style="background:#2c3e50; padding:20px; border-radius:10px; text-align:center; border:1px solid #f1c40f;">
                 <h3 style="color:#f1c40f;">马匹交易中心</h3>
                 <p style="color:#ecf0f1;">当前有人出价 <span id="horse-trade-price" style="color:#2ecc71; font-weight:bold;">0积分</span> 收购你的新秀马</p>
                 <p style="font-size:12px; color:#bdc3c7;">(交易后马匹将离开马厩，无法撤销)</p>
                 <div style="margin-top:20px;">
                     <button class="btn btn-green" onclick="game.confirmHorseTrade()">确认出售</button>
                     <button class="btn btn-blue" style="background:#7f8c8d" onclick="game.cancelHorseTrade()">取消</button>
                 </div>
             </div>
        </div>
    </div>
    <script type="module">
        // 模拟 Cocos 模块导入
        const _decorator = { ccclass: () => {}, property: () => {} };
        
        // --- 移植 Config.ts ---
        const Quality = { Normal: '普通', Rare: '稀有', Epic: '史诗', Legendary: '神兽' };
        // 基因类型 - 扩展至25个
        const GeneType = {
            // 基础类
            Speed: '疾风', Burst: '爆冲', Agile: '灵活', Swift: '神速', Dash: '飞驰',
            // 耐力类
            Stamina: '坚韧', Endurance: '持久', Recover: '回春', IronWill: '铁志', DeepBreath: '深息',
            // 稳定性类
            Stable: '稳健', Calm: '冷静', Focus: '专注', Steady: '草地', Balance: '平衡',
            // 特殊类
            Hybrid: '混血', LateBoomer: '大器', EarlyBird: '先锋', CornerKing: '雪地', SlopeRider: '沙地',
            // 稀有/神兽类
            Destiny: '天命', Miracle: '奇迹', Shadow: '残影', Meteor: '流星', Legend: '传说'
        };

        const allowedGeneTypesForQuality = (quality) => {
            const q = String(quality || '');
            let types = Object.values(GeneType);
            if (q !== '神兽') types = types.filter(t => t !== '天命');
            if (q !== '史诗' && q !== '神兽') types = types.filter(t => t !== '传说');
            return types;
        };

        const SpriteSet = {
            Horse: 'horse',
            Base: 'g',
            Rare: 'rare',
            Rare2: 'rare2',
            Epic: 'epic',
            Legendary: 'legendary',
            Legendary2: 'legendary2',
            Legendary3: 'legendary3'
        };

        const SpriteAssets = {
            [SpriteSet.Horse]: { dir: 'assets/sprites/horse_run', file: (i) => `${i}_horesrun.png` },
            [SpriteSet.Base]: { dir: 'assets/sprites/g_hores_run', file: (i) => `g_hores_run_${String((Number(i) || 1) - 1).padStart(4, '0')}.png` },
            [SpriteSet.Rare]: { dir: 'assets/sprites/2horse_run', file: (i) => `g_hores_run_${String((Number(i) || 1) - 1).padStart(4, '0')}.png` },
            [SpriteSet.Rare2]: { dir: 'assets/sprites/2g_hores_run', file: (i) => `3horse_run_${String((Number(i) || 1) - 1).padStart(4, '0')}.png` },
            [SpriteSet.Epic]: { dir: 'assets/sprites/3horse_run', file: (i) => `3horse_run_${String((Number(i) || 1) - 1).padStart(4, '0')}.png` },
            [SpriteSet.Legendary]: { dir: 'assets/sprites/4horse_run', file: (i) => `2horse_run_${String((Number(i) || 1) - 1).padStart(4, '0')}.png` },
            [SpriteSet.Legendary2]: { dir: 'assets/sprites/4g_horse_run/output', file: (i) => `4g_hores_run_${String((Number(i) || 1) - 1).padStart(4, '0')}.png` },
            [SpriteSet.Legendary3]: { dir: 'assets/sprites/5g_horse_run', file: (i) => `3horse_run_${String((Number(i) || 1) - 1).padStart(4, '0')}.png` }
        };

        const RaceSpriteScale = {
            [SpriteSet.Horse]: 1.1,
            [SpriteSet.Rare]: 1.064,
            [SpriteSet.Rare2]: 0.908,
            [SpriteSet.Epic]: 0.911,
            [SpriteSet.Legendary]: 0.966,
            [SpriteSet.Legendary2]: 0.885,
            [SpriteSet.Legendary3]: 0.971
        };

        const BurstAssets = {
            dir: 'assets/effects/chixiao_burst',
            frames: ['ef_001_p_gl_586.png', 'ef_001_p_gl_587.png', 'ef_001_p_gl_588.png']
        };
        const JifengAssets = {
            dir: 'assets/effects/18',
            frames: [
                'battleAttackSkill_20001.png', 'battleAttackSkill_20002.png', 'battleAttackSkill_20003.png', 'battleAttackSkill_20004.png'
            ]
        };
        const LanyingAssets = {
            dir: 'assets/effects/55',
            frames: [
                'battleBufferEffect9_10001.png', 'battleBufferEffect9_10002.png', 'battleBufferEffect9_10003.png',
                'battleBufferEffect9_10004.png', 'battleBufferEffect9_10005.png', 'battleBufferEffect9_10006.png',
                'battleBufferEffect9_10007.png', 'battleBufferEffect9_10008.png', 'battleBufferEffect9_10009.png',
                'battleBufferEffect9_10010.png'
            ]
        };
        const LieyanAssets = {
            dir: 'assets/effects/lieyan_burst',
            frames: [
                'battleAttack_60001.png', 'battleAttack_60002.png', 'battleAttack_60003.png',
                'battleAttack_60004.png', 'battleAttack_60005.png', 'battleAttack_60006.png'
            ]
        };
        const RuneEffectsAssets = {
            dir: 'assets/effects/runeffects',
            frames: ['1.png','2.png','3.png','4.png','5.png','6.png','7.png','8.png','9.png','10.png','11.png','12.png','13.png']
        };

        const NewYearGreetings = [
            '恭喜发财','新年快乐','万事如意','阖家幸福','心想事成','吉星高照','福星高照','财源广进','大吉大利','年年有余',
            '步步高升','事业有成','龙马精神','一帆风顺','平安喜乐','福寿安康','吉祥如意','花开富贵','五福临门','四季平安',
            '喜气盈门','鸿运当头','金玉满堂','喜乐安宁','春回大地','万象更新','瑞气盈门','财运亨通','福满人间','好事成双',
            '迎春纳福','福运绵长','岁岁安康','福泽深厚','喜上眉梢','开门见喜','紫气东来','万福齐臻','春风得意','福来运转'
        ];

        const NewYearPrefixes = ['新春','迎春','恭喜','万事','阖家','五福','四季','财源','福星','吉星','鸿运','瑞气','喜气','金玉','花开','岁岁','福寿','平安'];
        const NewYearSuffixes = ['纳福','进宝','如意','安康','临门','高照','盈门','满堂','顺遂','康泰','长久','吉祥','同庆','大吉','喜乐','团圆','昌盛','兴旺'];

        const QualityStats = {
            '普通': { baseSpeedMin: 52, baseSpeedMax: 58, stamina: 70, endurance: 1.00, accel: 0.78 },
            '中级': { baseSpeedMin: 56, baseSpeedMax: 62, stamina: 74, endurance: 1.08, accel: 0.82 },
            '高级': { baseSpeedMin: 60, baseSpeedMax: 68, stamina: 80, endurance: 1.16, accel: 0.86 },
            '稀有': { baseSpeedMin: 65, baseSpeedMax: 73, stamina: 88, endurance: 1.28, accel: 0.92 },
            '史诗': { baseSpeedMin: 70, baseSpeedMax: 80, stamina: 96, endurance: 1.40, accel: 0.97 },
            '神兽': { baseSpeedMin: 76, baseSpeedMax: 86, stamina: 105, endurance: 1.60, accel: 1.02 }
        };
        const getQualityStats = (quality) => QualityStats[quality] || QualityStats['普通'];
        const rollInt = (min, max) => {
            const a = Number(min) || 0;
            const b = Number(max) || 0;
            const lo = Math.min(a, b);
            const hi = Math.max(a, b);
            return Math.floor(lo + Math.random() * (hi - lo + 1));
        };

        const pickLegendarySpriteSet = () => {
            const r = Math.random();
            return r < 1/3 ? SpriteSet.Legendary : (r < 2/3 ? SpriteSet.Legendary2 : SpriteSet.Legendary3);
        };
        
        const InitialPlayer = {
            integral: 2000,
            ticketsNormal: 30,
            seasonNo: 1,
            spriteCodex: {},
            horses: [{
                id: 'h1', name: '赤兔', color: '#e63946', quality: '普通',
                baseSpeed: 55, stamina: 70, accel: 0.8, temper: 0.9,
                endurance: 1.0,
                lifespan: 50, maxLifespan: 50, 
                genes: [{type:'疾风', quality:'普通'}], 
                geneSlots: 6,
                spriteSet: SpriteSet.Horse,
                totalRaces: 0
            }, {
                id: 'g1', name: '小灰', color: '#74b9ff', quality: '普通',
                baseSpeed: 52, stamina: 65, accel: 0.75, temper: 0.8,
                endurance: 1.0,
                lifespan: 50, maxLifespan: 50,
                genes: [],
                geneSlots: 6,
                spriteSet: SpriteSet.Base,
                totalRaces: 0
            }],
            seasonWins: 0,
            seasonRaces: 0,
            seasonBottoms: 0, // 新增：倒数排名（4-5名）累计次数
            aiStable: [], // 新增 AI 马厩
            trophies: 0, // 新增：赛季冠军奖杯
            hasSeasonChampion: false // 新增：当前是否持有赛季冠军荣誉（持续一赛季）
        };

        // 初始化一些强力 AI 马
        function initAIStable() {
            // AI 马厩初始不放太强的，而是根据玩家初始马生成类似的
            const stable = [];
            // 生成4匹与玩家初始马质量相近的马
            for (let i = 0; i < 4; i++) {
                stable.push({
                    id: 'ai_base_'+i, name: 'AI-G'+i, color: '#aaa',
                    quality: '普通', // 初始默认普通，与玩家一致
                    baseSpeed: 55, stamina: 70, accel: 0.8, lifespan: 999,
                    endurance: 1.0,
                    genes: [], geneSlots: 6, // 初始与玩家一致
                    spriteSet: Math.random() < 0.35 ? SpriteSet.Base : SpriteSet.Horse
                });
            }
            return stable;
        }
        InitialPlayer.aiStable = initAIStable();

        function generateAIHorse(i, player, playerHorseOrQuality = '普通') {
            // 参数兼容：如果是字符串则为 quality，如果是对象则为 horse
            let playerHorseQuality = '普通';
            let playerBaseSpeed = 55;
            
            if (typeof playerHorseOrQuality === 'string') {
                playerHorseQuality = playerHorseOrQuality;
            } else if (playerHorseOrQuality && typeof playerHorseOrQuality === 'object') {
                playerHorseQuality = playerHorseOrQuality.quality || '普通';
                playerBaseSpeed = playerHorseOrQuality.baseSpeed || 55;
            }

            // 优先从 AI 马厩中选最强的出战
            // 评分标准：基础速度 + 技能评分
            const stable = player && player.aiStable ? player.aiStable : [];
            
            // 随着赛季进行，AI 强度动态提升
            // 简单模拟：赛季场次越多，生成的临时 AI 越强
            const seasonBonus = player ? (player.seasonRaces || 0) * 0.5 : 0;

            if (stable.length > 0) {
                 // 简单排序，选最好的
                 stable.sort((a,b) => b.baseSpeed - a.baseSpeed);
                 const best = stable[i % stable.length]; // 循环取，避免都取同一个
                 
                 // 如果是第一赛季前几场，强制将 AI 马的质量修正为与玩家一致，避免初始 AI 过强
                 // 这里的逻辑是：如果 AI 马是初始生成的（id包含 ai_base），则动态调整其属性
                 // 这样既保留了 AI 成长性（选秀截胡），又保证了初始公平
                 
                 let finalBaseSpeed = best.baseSpeed + seasonBonus;
                 let finalGeneSlots = best.geneSlots;
                 let finalQuality = best.quality;
                 
                 // 动态修正初始 AI
                 if (best.id.startsWith('ai_base_')) {
                     // 强制同步玩家等级
                     finalQuality = playerHorseQuality;
                     // 同步槽位
                     const slotsMap = { '普通': 3, '中级': 4, '高级': 5, '稀有': 6, '神兽': 6 };
                     // 注意：玩家初始马虽然是普通，但可能有6个槽（为了体验），所以这里 AI 也要对齐
                     // 如果玩家是普通但有6个槽，AI 也应该有6个槽
                     // 这里简化处理：直接读取玩家当前马的槽位数比较难（参数只传了 quality）
                     // 但我们可以根据 quality 给一个标准值，或者直接用 best.geneSlots (初始化时已设为6)
                     finalGeneSlots = 6; // 初始 AI 统一给 6 槽，与玩家一致
                     
                     // 修正速度：不能只看 quality，要参考玩家实际速度
                     // 限制 AI 速度不能超过玩家太多 (例如 +5)
                     const maxAllowed = playerBaseSpeed + 5;
                     
                     let baseSpd = 55;
                     if (finalQuality === '中级') baseSpd = 60;
                     else if (finalQuality === '高级') baseSpd = 65;
                     else if (finalQuality === '稀有') baseSpd = 70;
                     else if (finalQuality === '神兽') baseSpd = 75;
                     
                     // 应用软上限：确保 AI 成长是渐进的
                     finalBaseSpeed = Math.min(baseSpd + seasonBonus, maxAllowed);
                 }

                 // 克隆一个出战对象，避免修改原数据
                 return {
                     ...best,
                     id: 'ai_race_' + i + '_' + Date.now(),
                     quality: finalQuality,
                     geneSlots: finalGeneSlots,
                     baseSpeed: finalBaseSpeed,
                     stamina: (typeof best.stamina === 'number' ? best.stamina : getQualityStats(finalQuality).stamina),
                     endurance: (typeof best.endurance === 'number' ? best.endurance : getQualityStats(finalQuality).endurance),
                     accel: (typeof best.accel === 'number' ? best.accel : getQualityStats(finalQuality).accel),
                     spriteSet: finalQuality === '神兽'
                        ? pickLegendarySpriteSet()
                        : (finalQuality === '史诗'
                            ? SpriteSet.Epic
                            : (finalQuality === '稀有'
                                ? (Math.random() < 0.5 ? SpriteSet.Rare : SpriteSet.Rare2)
                                : (best.spriteSet || (Math.random() < 0.35 ? SpriteSet.Base : SpriteSet.Horse))))
                 };
            }
            
            // 如果马厩没马，生成临时的
            // 动态匹配玩家马的质量：尽量生成同级或稍弱的马，偶尔生成更强的
            const ladder = ['普通','中级','高级','稀有','神兽'];
            let qIdx = ladder.indexOf(playerHorseQuality);
            if (qIdx === -1) qIdx = 0;
            
            // 随机波动：-1 到 +1 之间，模拟匹配
            let aiQIdx = qIdx + Math.floor(Math.random() * 3) - 1;
            aiQIdx = Math.max(0, Math.min(ladder.length - 1, aiQIdx));
            const aiQuality = ladder[aiQIdx];
            
            // 根据质量设定基础属性
            const qs = getQualityStats(aiQuality);
            let baseSpd = rollInt(qs.baseSpeedMin, qs.baseSpeedMax);
            let slots = 3;
            // 玩家初始马是普通但有6槽，为了公平，如果 AI 匹配到普通，也给它多点槽位
            if (aiQuality === '普通') slots = 6; 
            else if (aiQuality === '中级') { slots = 4; }
            else if (aiQuality === '高级') { slots = 5; }
            else if (aiQuality === '稀有') { slots = 6; }
            else if (aiQuality === '神兽') { slots = 6; }
            
            // 限制 AI 速度上限：不超过玩家速度 + 5 + 赛季加成
            // 这样即使随机到了高等级马，数值也不会太离谱
            const cappedSpeed = Math.min(baseSpd, playerBaseSpeed + 5);
            
            return {
                id: 'ai_'+i, name: 'AI-'+i, 
                color: aiQuality==='神兽'?'#e74c3c':(aiQuality==='史诗'?'#9b59b6':(aiQuality==='稀有'?'#f1c40f':'#ecf0f1')),
                quality: aiQuality,
                baseSpeed: Math.round(cappedSpeed + Math.random() * 5 + seasonBonus), 
                stamina: qs.stamina,
                endurance: qs.endurance,
                accel: qs.accel, lifespan: 50,
                genes: [], geneSlots: slots,
                spriteSet: aiQuality === '神兽'
                    ? pickLegendarySpriteSet()
                    : (aiQuality === '史诗'
                        ? SpriteSet.Epic
                        : (aiQuality === '稀有'
                            ? (Math.random() < 0.5 ? SpriteSet.Rare : SpriteSet.Rare2)
                            : (Math.random() < 0.35 ? SpriteSet.Base : SpriteSet.Horse)))
            };
        }

        // --- 移植 BreedingSystem.ts (简化版) ---
        const BreedingSystem = {
            breedHorse(p1, p2) {
                const name = p1.name[0] + p2.name[p2.name.length-1] + '驹';
                const ladder = ['普通','中级','高级','稀有'];
                const quality = ladder[Math.floor(Math.random() * ladder.length)];
                const qs = getQualityStats(quality);
                const qMid = (qs.baseSpeedMin + qs.baseSpeedMax) / 2;
                const slotsMap = { '普通': 3, '中级': 4, '高级': 5, '稀有': 6 };
                const geneSlots = slotsMap[quality] || 3;
                
                const allTypes = allowedGeneTypesForQuality(quality);
                const poolCount = Math.max(1, Math.min(6, Math.floor(Math.random() * 6) + 1));
                const shuffled = [...allTypes].sort(() => 0.5 - Math.random());
                const chosen = shuffled.slice(0, poolCount);
                const rareIndex = Math.floor(Math.random() * chosen.length);
                let genes = chosen.map((t, idx) => ({ type: t, quality: idx === rareIndex ? '稀有' : '普通' }));
                
                // 从父级保留一个最高稀有度技能
                const parentGenes = ([]).concat(p1.genes || [], p2.genes || []);
                if (parentGenes.length > 0) {
                    const rank = { '普通': 0, '中级': 1, '高级': 2, '稀有': 3 };
                    const maxRank = parentGenes.reduce((m, g) => Math.max(m, rank[g.quality] ?? 0), 0);
                    const topGenes = parentGenes.filter(g => (rank[g.quality] ?? 0) === maxRank);
                    const keep = topGenes[Math.floor(Math.random() * topGenes.length)];
                    if (keep) {
                        const idx = genes.findIndex(g => g.type === keep.type);
                        if (idx !== -1) {
                            // 升级为父级的最高稀有度
                            const rr = { '普通': 0, '中级': 1, '高级': 2, '稀有': 3 };
                            if ((rr[genes[idx].quality] ?? 0) < (rr[keep.quality] ?? 0)) {
                                genes[idx].quality = keep.quality;
                            }
                        } else {
                            // 将父级技能加入，并保证总数不超过6
                            genes.unshift({ type: keep.type, quality: keep.quality });
                            // 去重并截断到最多6个
                            const uniq = new Map();
                            genes.forEach(g => { if (!uniq.has(g.type)) uniq.set(g.type, g); });
                            genes = Array.from(uniq.values()).slice(0, 6);
                        }
                    }
                }
                
                return {
                    id: 'bred_'+Date.now(), name,
                    color: quality==='神兽'?'#e74c3c':(quality==='史诗'?'#9b59b6':(quality==='稀有'?'#f1c40f':'#ecf0f1')),
                    quality,
                    baseSpeed: Math.max(qs.baseSpeedMin, Math.min(qs.baseSpeedMax, Math.round(((p1.baseSpeed + p2.baseSpeed) / 2) * 1.03 + (qMid - 55) * 0.15))),
                    stamina: qs.stamina,
                    endurance: qs.endurance,
                    accel: qs.accel,
                    temper: 0.5,
                    lifespan: 50, maxLifespan: 50, genes, geneSlots,
                    spriteSet: quality === '神兽'
                        ? pickLegendarySpriteSet()
                        : (quality === '史诗'
                            ? SpriteSet.Epic
                            : (quality === '稀有'
                                ? (Math.random() < 0.5 ? SpriteSet.Rare : SpriteSet.Rare2)
                                : (Math.random() < 0.5 ? (p1.spriteSet || SpriteSet.Horse) : (p2.spriteSet || SpriteSet.Horse)))),
                    totalRaces: 0
                };
            },
            
            reforgeSkills(horse) {
                if (!horse.genes || horse.genes.length === 0) return null;
                
                const count = horse.genes.length;
                const newGenes = [];
                const allTypes = allowedGeneTypesForQuality(horse.quality);
                // 洗牌
                const shuffled = [...allTypes].sort(() => 0.5 - Math.random());
                
                for(let i=0; i<count; i++) {
                    if (i >= shuffled.length) break;
                    const type = shuffled[i];
                    const quality = Math.random() < 0.1 ? '稀有' : '普通';
                    newGenes.push({ type, quality });
                }
                return newGenes;
            }
        };

        // --- 简易游戏引擎 ---
        class Game {
            constructor() {
                this.player = JSON.parse(JSON.stringify(InitialPlayer));
                this.selectedHorseId = this.player.horses[0].id; // 默认选中第一匹
                this.horses = [];
                this.racing = false;
                this.stableCap = 8;
                this.stablePageSize = 4;
                this.stablePage = 0;
                this.bgmEnabled = (localStorage.getItem('bgmEnabled') ?? '1') !== '0';
                this.bgmVolume = Math.max(0, Math.min(1, Number(localStorage.getItem('bgmVolume') ?? 0.35) || 0.35));
                this.bgmTracks = ['bgm/bgm1.MP3'];
                this.bgmIndex = 0;
                this.bgm = null;
                this._bgmUserGestureHandler = null;
                this._bgmPlayPromise = null;
                this.sceneDefs = {
                    '草地': { bg: 'backround/export_1%20(9).jpg', color: '#c6f98b' },
                    '雪地': { bg: 'backround/export_1%20(10).jpg', color: '#e7f4ff' },
                    '沙地': { bg: 'backround/export_1%20(11).jpg', color: '#f1c58d' }
                };
                this.sceneType = '草地';
                this.sceneBgSrc = this.sceneDefs[this.sceneType].bg;
                this.sceneBgColor = this.sceneDefs[this.sceneType].color;
                this._sceneTileDataUrl = null;
                this._sceneTilePromise = null;
                this._preloadNextScenePromise = null;
                this.idleAnimTimer = null;
                this.idleAnimRaf = 0;
                this.idleAnimLastTs = 0;
                this.idleAnimAcc = 0;
                this.idleAnimFrame = 1;
                this.avatarDirPath = 'Test Friend Avatar';
                this.avatarList = null;
                this.horseRunFrameCss = null;
                this.horseRunFramesReady = null;
                this.horseRunImages = null;
                this.horseRunFrameCounts = null;
                this.idleLastFrameBySet = {};
                this.burstFrameCss = null;
                this.burstFramesReady = null;
                this.burstImages = null;
                this.jifengFrameCss = null;
                this.jifengFramesReady = null;
                this.jifengImages = null;
                this.lanyingFrameCss = null;
                this.lanyingFramesReady = null;
                this.lanyingImages = null;
                this.lieyanFrameCss = null;
                this.lieyanFramesReady = null;
                this.lieyanImages = null;
                this.runeffectsFrameCss = null;
                this.runeffectsFramesReady = null;
                this.runeffectsImages = null;
                this.stableIdleToken = 0;
                this.draftPreviewAnimTimer = null;
                this.draftPreviewAnimRaf = 0;
                this.draftPreviewLastTs = 0;
                this.draftPreviewAcc = 0;
                this.draftPreviewFrame = 1;
                this.draftPreviewToken = 0;
                this.codexToken = 0;
                this.trackMarksEl = null;
                this.trackMarksMax = 420;

                if (!this.player.spriteCodex || typeof this.player.spriteCodex !== 'object') this.player.spriteCodex = {};

                const baseHorse = this.player.horses.find(h => h && h.id === 'g1');
                if (baseHorse && (!Array.isArray(baseHorse.genes) || baseHorse.genes.length === 0)) {
                    const allTypes = allowedGeneTypesForQuality(baseHorse.quality);
                    const type = allTypes[Math.floor(Math.random() * allTypes.length)];
                    baseHorse.genes = [{ type, quality: '普通' }];
                }
                
                // 初始化宿敌池 (4匹固定对手，减少数量以优化显示)
                this.rivals = Array.from({length: 4}, (_, i) => generateAIHorse(i));
                
                this.horseRunFramesReady = this.preloadHorseRunFrames();
                this.burstFramesReady = this.preloadBurstFrames();
                this.jifengFramesReady = this.preloadJifengFrames();
                this.lanyingFramesReady = this.preloadLanyingFrames();
                this.lieyanFramesReady = this.preloadLieyanFrames();
                this.runeffectsFramesReady = this.preloadRuneEffectsFrames();
                this.initBgm();
                this.prepareSceneTile();
                this.updateUI();
                this.initAvatarFlow();
                setTimeout(() => this.preloadNextScene(), 60);
                
                // 临时变量
                this.tempReforgeGenes = null;
            }

            initBgm() {
                if (!Array.isArray(this.bgmTracks) || this.bgmTracks.length === 0) return;
                const src = this.bgmTracks[this.bgmIndex] || this.bgmTracks[0];
                try {
                    this.bgm = new Audio(src);
                    this.bgm.loop = true;
                    this.bgm.volume = this.bgmVolume;
                    this.bgm.preload = 'auto';
                } catch (e) {
                    this.bgm = null;
                    return;
                }
                this._bgmUserGestureHandler = () => this.tryStartBgm();
                document.addEventListener('pointerdown', this._bgmUserGestureHandler, { passive: true });
                document.addEventListener('keydown', this._bgmUserGestureHandler);
            }

            tryStartBgm() {
                if (!this.bgmEnabled || !this.bgm) return;
                if (this._bgmPlayPromise) return;
                this._bgmPlayPromise = this.bgm.play().then(() => {
                    this._bgmPlayPromise = null;
                    if (this._bgmUserGestureHandler) {
                        document.removeEventListener('pointerdown', this._bgmUserGestureHandler);
                        document.removeEventListener('keydown', this._bgmUserGestureHandler);
                        this._bgmUserGestureHandler = null;
                    }
                }).catch(() => {
                    this._bgmPlayPromise = null;
                });
            }

            toggleBgm() {
                this.bgmEnabled = !this.bgmEnabled;
                localStorage.setItem('bgmEnabled', this.bgmEnabled ? '1' : '0');
                if (this.bgmEnabled) this.tryStartBgm();
                else if (this.bgm) this.bgm.pause();
                this.updateUI();
            }

            selectRandomScene() {
                const keys = Object.keys(this.sceneDefs || {});
                if (keys.length === 0) return;
                const next = keys[Math.floor(Math.random() * keys.length)];
                this.setScene(next);
            }

            setScene(sceneType) {
                const t = String(sceneType || '').trim();
                const def = this.sceneDefs && this.sceneDefs[t] ? this.sceneDefs[t] : null;
                if (!def) return;
                this.sceneType = t;
                this.sceneBgSrc = def.bg;
                this.sceneBgColor = def.color;
                this._sceneTileDataUrl = null;
                const track = document.getElementById('track-layer');
                if (track) track.style.backgroundColor = this.sceneBgColor;
                this.prepareSceneTile();
            }

            preloadNextScene() {
                if (this.racing) return Promise.resolve(false);
                if (this._preloadNextScenePromise) return this._preloadNextScenePromise;
                const keys = Object.keys(this.sceneDefs || {});
                if (keys.length === 0) return Promise.resolve(false);
                const current = this.sceneType;
                let next = current;
                if (keys.length > 1) {
                    for (let i = 0; i < 6; i++) {
                        const cand = keys[Math.floor(Math.random() * keys.length)];
                        if (cand && cand !== current) { next = cand; break; }
                    }
                } else {
                    next = keys[0];
                }
                this._preloadNextScenePromise = Promise.resolve().then(async () => {
                    this.setScene(next);
                    return await this.prepareSceneTile();
                }).catch(() => false).finally(() => {
                    this._preloadNextScenePromise = null;
                });
                return this._preloadNextScenePromise;
            }

            prepareSceneTile() {
                if (this._sceneTileDataUrl) {
                    this.applySceneBackground();
                    return Promise.resolve(true);
                }
                if (this._sceneTilePromise) return this._sceneTilePromise;
                const src = this.sceneBgSrc;
                if (!src) return Promise.resolve(false);
                const img = new Image();
                this._sceneTilePromise = new Promise(resolve => {
                    const done = (ok) => {
                        this._sceneTilePromise = null;
                        resolve(!!ok);
                    };
                    img.onload = () => {
                        const w = img.naturalWidth || 0;
                        const h = img.naturalHeight || 0;
                        if (!w || !h) return done(false);
                        const canvas = document.createElement('canvas');
                        canvas.width = w * 2;
                        canvas.height = h;
                        const ctx = canvas.getContext('2d');
                        if (!ctx) return done(false);
                        ctx.drawImage(img, 0, 0, w, h);
                        ctx.save();
                        ctx.translate(canvas.width, 0);
                        ctx.scale(-1, 1);
                        ctx.drawImage(img, 0, 0, w, h);
                        ctx.restore();
                        this._sceneTileDataUrl = canvas.toDataURL('image/png');
                        this.applySceneBackground();
                        done(true);
                    };
                    img.onerror = () => done(false);
                });
                img.src = src;
                return this._sceneTilePromise;
            }

            applySceneBackground() {
                const track = document.getElementById('track-layer');
                if (!track) return;
                const tile = this._sceneTileDataUrl;
                if (!tile) return;
                if (this.sceneBgColor) track.style.backgroundColor = this.sceneBgColor;
                track.style.backgroundImage = `url('${tile}'), linear-gradient(0deg, rgba(0,0,0,0.10), rgba(0,0,0,0.00) 30%, rgba(0,0,0,0.00) 70%, rgba(0,0,0,0.12))`;
                track.style.backgroundRepeat = 'repeat, no-repeat';
                track.style.backgroundSize = 'auto 100%, 100% 100%';
            }

            openSceneTransition(title, sub) {
                const el = document.getElementById('scene-transition');
                if (!el) return;
                el.classList.remove('fade-black');
                const t = document.getElementById('scene-transition-title');
                const s = document.getElementById('scene-transition-sub');
                if (t) t.innerText = String(title ?? '加载地图');
                if (s) s.innerText = String(sub ?? '正在准备赛道...');
                el.style.display = 'flex';
                requestAnimationFrame(() => el.classList.add('show'));
            }

            setSceneTransitionFadeMode(enabled) {
                const el = document.getElementById('scene-transition');
                if (!el) return;
                if (enabled) el.classList.add('fade-black');
                else el.classList.remove('fade-black');
            }

            waitFrames(count = 1) {
                const n = Math.max(1, Number(count) || 1);
                return new Promise(resolve => {
                    let i = 0;
                    const step = () => {
                        i++;
                        if (i >= n) resolve(true);
                        else requestAnimationFrame(step);
                    };
                    requestAnimationFrame(step);
                });
            }

            waitTransitionEnd(el, propertyName, timeoutMs = 800) {
                const target = el;
                const prop = String(propertyName || '').trim();
                const timeout = Math.max(0, Number(timeoutMs) || 0);
                if (!target || !prop) return Promise.resolve(false);
                return new Promise(resolve => {
                    let done = false;
                    const finish = (ok) => {
                        if (done) return;
                        done = true;
                        target.removeEventListener('transitionend', onEnd);
                        resolve(!!ok);
                    };
                    const onEnd = (e) => {
                        if (!e) return;
                        if (e.target !== target) return;
                        if (e.propertyName !== prop) return;
                        finish(true);
                    };
                    target.addEventListener('transitionend', onEnd);
                    if (timeout > 0) setTimeout(() => finish(false), timeout);
                });
            }

            async closeSceneTransition() {
                const el = document.getElementById('scene-transition');
                if (!el) return;
                el.classList.remove('show');
                await new Promise(r => setTimeout(r, 650));
                el.style.display = 'none';
            }

            openTrophyShop() {
                const modal = document.getElementById('trophy-shop-modal');
                if (modal) modal.style.display = 'flex';
                this.renderTrophyShop();
            }

            closeTrophyShop() {
                const modal = document.getElementById('trophy-shop-modal');
                if (modal) modal.style.display = 'none';
            }

            renderTrophyShop() {
                const balEl = document.getElementById('trophy-shop-balance');
                const itemsEl = document.getElementById('trophy-shop-items');
                if (!balEl || !itemsEl) return;
                const trophies = Number(this.player && this.player.trophies) || 0;
                balEl.innerText = String(trophies);
                const canAfford = (cost) => trophies >= cost;
                const btn = (label, cost, quality, detail) => {
                    const disabled = canAfford(cost) ? '' : 'disabled';
                    const btnStyle = canAfford(cost) ? '' : 'background:#7f8c8d; box-shadow:0 4px #666; opacity:0.8;';
                    return `
                        <div class="trophy-item">
                            <div class="left">
                                <div class="name">${label}</div>
                                <div class="desc">${detail}</div>
                            </div>
                            <div class="right">
                                <div class="cost">消耗 ${cost} 点</div>
                                <button class="btn btn-blue" style="width:110px; ${btnStyle}" ${disabled} onclick="game.redeemTrophyShop('${quality}')">兑换</button>
                            </div>
                        </div>
                    `;
                };
                itemsEl.innerHTML =
                    btn('稀有造型马', 1, '稀有', '兑换一匹稀有造型新马（随机稀有造型）') +
                    btn('史诗造型马', 2, '史诗', '兑换一匹史诗造型新马') +
                    btn('神兽造型马', 3, '神兽', '兑换一匹神兽造型新马（随机神兽造型）');
            }

            redeemTrophyShop(quality) {
                const q = String(quality || '');
                const costMap = { '稀有': 1, '史诗': 2, '神兽': 3 };
                const cost = costMap[q] || 9999;
                const trophies = Number(this.player && this.player.trophies) || 0;
                if (trophies < cost) {
                    alert(`奖杯积分不足（需要 ${cost} 点）。`);
                    return;
                }
                if (this.player && Array.isArray(this.player.horses) && this.player.horses.length >= this.stableCap) {
                    alert(`马厩已满 (${this.player.horses.length}/${this.stableCap})，请先清理一个马厩空位再兑换。`);
                    return;
                }
                if (!confirm(`确认消耗 ${cost} 点奖杯积分，兑换【${q}】造型马吗？`)) return;
                this.player.trophies = trophies - cost;
                const name = `兑换·${q}造型`;
                const horse = this.createDraftHorseData(q, name);
                horse.id = 'shop_' + Date.now() + '_' + Math.floor(Math.random() * 100000);
                this.player.horses.push(horse);
                this.selectedHorseId = horse.id;
                const pageSize = this.stablePageSize || 4;
                const idx = this.player.horses.findIndex(h => h && h.id === horse.id);
                if (idx >= 0) this.stablePage = Math.floor(idx / pageSize);
                this.pushHint(`🏆 兑换成功：${horse.name}`);
                this.updateUI();
                this.renderTrophyShop();
            }

            escapeHtml(value) {
                return String(value ?? '')
                    .replaceAll('&', '&amp;')
                    .replaceAll('<', '&lt;')
                    .replaceAll('>', '&gt;')
                    .replaceAll('"', '&quot;')
                    .replaceAll("'", '&#39;');
            }

            pickUniqueNewYearName(used) {
                const usedSet = used instanceof Set ? used : new Set();
                const pool = [...NewYearGreetings].sort(() => 0.5 - Math.random());
                for (const n of pool) {
                    if (!usedSet.has(n)) {
                        usedSet.add(n);
                        return n;
                    }
                }
                for (let t = 0; t < 200; t++) {
                    const n = NewYearPrefixes[Math.floor(Math.random() * NewYearPrefixes.length)] +
                        NewYearSuffixes[Math.floor(Math.random() * NewYearSuffixes.length)];
                    if (n.length === 4 && !usedSet.has(n)) {
                        usedSet.add(n);
                        return n;
                    }
                }
                for (let i = 0; i < 9999; i++) {
                    const n = '新春纳福';
                    const cand = i === 0 ? n : (n.slice(0, 2) + String(i).padStart(2, '0').slice(-2));
                    if (!usedSet.has(cand)) {
                        usedSet.add(cand);
                        return cand;
                    }
                }
                return '新年快乐';
            }

            preloadHorseRunFrames() {
                if (this.horseRunFrameCss && typeof this.horseRunFrameCss === 'object') return this.horseRunFramesReady || Promise.resolve(true);
                const frameCount = 20;
                const sets = {};
                const images = {};
                const decodes = [];

                for (const [key, def] of Object.entries(SpriteAssets)) {
                    const list = new Array(frameCount + 1);
                    const imgList = new Array(frameCount + 1);
                    for (let i = 1; i <= frameCount; i++) {
                        const url = `${def.dir}/${def.file(i)}`;
                        list[i] = `url('${url}')`;
                        const img = new Image();
                        img.decoding = 'async';
                        img.loading = 'eager';
                        const ready = new Promise(resolve => {
                            img.onload = () => resolve(true);
                            img.onerror = () => resolve(false);
                        });
                        img.src = url;
                        imgList[i] = img;
                        decodes.push(typeof img.decode === 'function' ? img.decode().then(() => true).catch(() => ready) : ready);
                    }
                    sets[key] = list;
                    images[key] = imgList;
                }

                this.horseRunFrameCss = sets;
                this.horseRunImages = images;
                this.horseRunFramesReady = Promise.all(decodes).then(() => {
                    const counts = {};
                    for (const [key, imgList] of Object.entries(images)) {
                        let maxOk = 0;
                        if (Array.isArray(imgList)) {
                            for (let i = imgList.length - 1; i >= 1; i--) {
                                const img = imgList[i];
                                if (img && img.complete && img.naturalWidth > 0) {
                                    maxOk = i;
                                    break;
                                }
                            }
                        }
                        counts[key] = Math.max(1, maxOk || 0);
                    }
                    this.horseRunFrameCounts = counts;
                    return true;
                });
                return this.horseRunFramesReady;
            }

            preloadBurstFrames() {
                if (this.burstFrameCss && typeof this.burstFrameCss === 'object') return this.burstFramesReady || Promise.resolve(true);
                const frameCount = BurstAssets.frames.length;
                const list = new Array(frameCount + 1);
                const imgList = new Array(frameCount + 1);
                const decodes = [];
                for (let i = 1; i <= frameCount; i++) {
                    const url = `${BurstAssets.dir}/${BurstAssets.frames[i - 1]}`;
                    list[i] = `url('${url}')`;
                    const img = new Image();
                    img.decoding = 'async';
                    img.loading = 'eager';
                    const ready = new Promise(resolve => {
                        img.onload = () => resolve(true);
                        img.onerror = () => resolve(false);
                    });
                    img.src = url;
                    imgList[i] = img;
                    decodes.push(typeof img.decode === 'function' ? img.decode().then(() => true).catch(() => ready) : ready);
                }
                this.burstFrameCss = { chixiao: list };
                this.burstImages = { chixiao: imgList };
                this.burstFramesReady = Promise.all(decodes).then(() => true);
                return this.burstFramesReady;
            }

            preloadJifengFrames() {
                if (this.jifengFrameCss && typeof this.jifengFrameCss === 'object') return this.jifengFramesReady || Promise.resolve(true);
                const frameCount = JifengAssets.frames.length;
                const list = new Array(frameCount + 1);
                const imgList = new Array(frameCount + 1);
                const decodes = [];
                for (let i = 1; i <= frameCount; i++) {
                    const url = `${JifengAssets.dir}/${JifengAssets.frames[i - 1]}`;
                    list[i] = `url('${url}')`;
                    const img = new Image();
                    img.decoding = 'async';
                    img.loading = 'eager';
                    const ready = new Promise(resolve => {
                        img.onload = () => resolve(true);
                        img.onerror = () => resolve(false);
                    });
                    img.src = url;
                    imgList[i] = img;
                    decodes.push(typeof img.decode === 'function' ? img.decode().then(() => true).catch(() => ready) : ready);
                }
                this.jifengFrameCss = { jifeng: list };
                this.jifengImages = { jifeng: imgList };
                this.jifengFramesReady = Promise.all(decodes).then(() => true);
                return this.jifengFramesReady;
            }

            preloadRuneEffectsFrames() {
                if (this.runeffectsFrameCss && typeof this.runeffectsFrameCss === 'object') return this.runeffectsFramesReady || Promise.resolve(true);
                const frameCount = RuneEffectsAssets.frames.length;
                const list = new Array(frameCount + 1);
                const imgList = new Array(frameCount + 1);
                const decodes = [];
                for (let i = 1; i <= frameCount; i++) {
                    const url = `${RuneEffectsAssets.dir}/${RuneEffectsAssets.frames[i - 1]}`;
                    list[i] = `url('${url}')`;
                    const img = new Image();
                    img.decoding = 'async';
                    img.loading = 'eager';
                    const ready = new Promise(resolve => {
                        img.onload = () => resolve(true);
                        img.onerror = () => resolve(false);
                    });
                    img.src = url;
                    imgList[i] = img;
                    decodes.push(typeof img.decode === 'function' ? img.decode().then(() => true).catch(() => ready) : ready);
                }
                this.runeffectsFrameCss = { dust: list };
                this.runeffectsImages = { dust: imgList };
                this.runeffectsFramesReady = Promise.all(decodes).then(() => true);
                return this.runeffectsFramesReady;
            }

            preloadLanyingFrames() {
                if (this.lanyingFrameCss && typeof this.lanyingFrameCss === 'object') return this.lanyingFramesReady || Promise.resolve(true);
                const frameCount = LanyingAssets.frames.length;
                const list = new Array(frameCount + 1);
                const imgList = new Array(frameCount + 1);
                const decodes = [];
                for (let i = 1; i <= frameCount; i++) {
                    const url = `${LanyingAssets.dir}/${LanyingAssets.frames[i - 1]}`;
                    list[i] = `url('${url}')`;
                    const img = new Image();
                    img.decoding = 'async';
                    img.loading = 'eager';
                    const ready = new Promise(resolve => {
                        img.onload = () => resolve(true);
                        img.onerror = () => resolve(false);
                    });
                    img.src = url;
                    imgList[i] = img;
                    decodes.push(typeof img.decode === 'function' ? img.decode().then(() => true).catch(() => ready) : ready);
                }
                this.lanyingFrameCss = { lanying: list };
                this.lanyingImages = { lanying: imgList };
                this.lanyingFramesReady = Promise.all(decodes).then(() => true);
                return this.lanyingFramesReady;
            }

            preloadLieyanFrames() {
                if (this.lieyanFrameCss && typeof this.lieyanFrameCss === 'object') return this.lieyanFramesReady || Promise.resolve(true);
                const frameCount = LieyanAssets.frames.length;
                const list = new Array(frameCount + 1);
                const imgList = new Array(frameCount + 1);
                const decodes = [];
                for (let i = 1; i <= frameCount; i++) {
                    const url = `${LieyanAssets.dir}/${LieyanAssets.frames[i - 1]}`;
                    list[i] = `url('${url}')`;
                    const img = new Image();
                    img.decoding = 'async';
                    img.loading = 'eager';
                    const ready = new Promise(resolve => {
                        img.onload = () => resolve(true);
                        img.onerror = () => resolve(false);
                    });
                    img.src = url;
                    imgList[i] = img;
                    decodes.push(typeof img.decode === 'function' ? img.decode().then(() => true).catch(() => ready) : ready);
                }
                this.lieyanFrameCss = { lieyan: list };
                this.lieyanImages = { lieyan: imgList };
                this.lieyanFramesReady = Promise.all(decodes).then(() => true);
                return this.lieyanFramesReady;
            }

            horseRunFrame(i, spriteSetKey) {
                const idx = Number(i) || 1;
                const key = (spriteSetKey && this.horseRunFrameCss && this.horseRunFrameCss[spriteSetKey]) ? spriteSetKey : SpriteSet.Horse;
                const list = this.horseRunFrameCss && this.horseRunFrameCss[key];
                if (Array.isArray(list) && list[idx]) return list[idx];
                const def = SpriteAssets[key] || SpriteAssets[SpriteSet.Horse];
                return `url('${def.dir}/${def.file(idx)}')`;
            }

            horseRunFrameCount(spriteSetKey) {
                const key = (spriteSetKey && this.horseRunFrameCss && this.horseRunFrameCss[spriteSetKey]) ? spriteSetKey : SpriteSet.Horse;
                const counts = this.horseRunFrameCounts;
                const n = counts && counts[key];
                return Number.isFinite(n) && n > 0 ? n : 20;
            }

            horseRunFrameReady(i, spriteSetKey) {
                const idx = Number(i) || 1;
                const key = (spriteSetKey && this.horseRunFrameCss && this.horseRunFrameCss[spriteSetKey]) ? spriteSetKey : SpriteSet.Horse;
                const imgs = this.horseRunImages && this.horseRunImages[key];
                const img = imgs && imgs[idx];
                if (!img) return true;
                return !!(img.complete && img.naturalWidth > 0);
            }

            waitImageReady(img, timeoutMs = 1800) {
                const node = img;
                if (!node) return Promise.resolve(false);
                if (node.complete && node.naturalWidth > 0) return Promise.resolve(true);
                return new Promise(resolve => {
                    let done = false;
                    let t = 0;
                    const finish = (ok) => {
                        if (done) return;
                        done = true;
                        if (t) clearTimeout(t);
                        resolve(!!ok);
                    };
                    const onLoad = () => finish(true);
                    const onErr = () => finish(false);
                    try {
                        node.addEventListener('load', onLoad, { once: true });
                        node.addEventListener('error', onErr, { once: true });
                    } catch (_) {}
                    t = setTimeout(() => finish(false), Math.max(0, Number(timeoutMs) || 0));
                });
            }

            async prewarmHorseRunFrames(spriteSets, frames = [1, 2]) {
                if (!Array.isArray(spriteSets) || spriteSets.length === 0) return;
                if (!this.horseRunFrameCss || !this.horseRunImages) {
                    try { if (!this.horseRunFramesReady) this.horseRunFramesReady = this.preloadHorseRunFrames(); } catch (_) {}
                }
                const tasks = [];
                for (const setKey of spriteSets) {
                    const key = (setKey && this.horseRunFrameCss && this.horseRunFrameCss[setKey]) ? setKey : SpriteSet.Horse;
                    const imgs = this.horseRunImages && this.horseRunImages[key];
                    if (!imgs) continue;
                    for (const f of frames) {
                        const idx = Number(f) || 1;
                        const img = imgs[idx];
                        if (!img) continue;
                        tasks.push(this.waitImageReady(img, 1800));
                    }
                }
                await Promise.allSettled(tasks);
            }

            async ensureHorseRunFramesReady() {
                try {
                    if (!this.horseRunFramesReady) this.horseRunFramesReady = this.preloadHorseRunFrames();
                    await this.horseRunFramesReady;
                } catch (_) {}
            }

            async ensureBurstFramesReady() {
                try {
                    if (!this.burstFramesReady) this.burstFramesReady = this.preloadBurstFrames();
                    await this.burstFramesReady;
                } catch (_) {}
            }

            async ensureJifengFramesReady() {
                try {
                    if (!this.jifengFramesReady) this.jifengFramesReady = this.preloadJifengFrames();
                    await this.jifengFramesReady;
                } catch (_) {}
            }

            async ensureLanyingFramesReady() {
                try {
                    if (!this.lanyingFramesReady) this.lanyingFramesReady = this.preloadLanyingFrames();
                    await this.lanyingFramesReady;
                } catch (_) {}
            }

            async ensureLieyanFramesReady() {
                try {
                    if (!this.lieyanFramesReady) this.lieyanFramesReady = this.preloadLieyanFrames();
                    await this.lieyanFramesReady;
                } catch (_) {}
            }

            async ensureRuneEffectsFramesReady() {
                try {
                    if (!this.runeffectsFramesReady) this.runeffectsFramesReady = this.preloadRuneEffectsFrames();
                    await this.runeffectsFramesReady;
                } catch (_) {}
            }

            truncateRaceName(name) {
                const s = String(name ?? '');
                const isAscii = /^[\x00-\x7F]*$/.test(s);
                const maxLen = isAscii ? 6 : 4;
                return s.length > maxLen ? s.slice(0, maxLen) : s;
            }

            setHorseName(horseId, nextName) {
                const horse = this.player.horses.find(h => h.id === horseId);
                if (!horse) return;
                const raw = String(nextName ?? '');
                const cleaned = raw.trim().slice(0, 12);
                horse.name = cleaned || horse.name;
            }

            pushHint(message) {
                if (!this.hints) this.hints = [];
                const text = String(message ?? '').trim();
                if (!text) return;
                this.hints.push(text);
                if (this.hints.length > 12) this.hints = this.hints.slice(-12);
            }

            renderHintsHtml() {
                const list = Array.isArray(this.hints) && this.hints.length > 0
                    ? this.hints
                    : ['左右滑动查看马厩，点技能查看说明'];
                return list.map(t => `<div class="hint-chip">${this.escapeHtml(t)}</div>`).join('');
            }

            getHintText() {
                const list = Array.isArray(this.hints) && this.hints.length > 0
                    ? this.hints
                    : ['左右滑动查看马厩，点技能查看说明'];
                return String(list[list.length - 1] ?? '').trim();
            }

            getAvatarConsent() {
                return localStorage.getItem('wechatAvatarConsent');
            }

            setAvatarConsent(value) {
                localStorage.setItem('wechatAvatarConsent', value);
            }

            initAvatarFlow() {
                const consent = this.getAvatarConsent();
                if (consent === 'granted') {
                    this.ensureAvatarLoaded();
                    return;
                }
                if (consent === 'denied') return;
                this.openAvatarAuthModal();
            }

            openAvatarAuthModal() {
                const modal = document.getElementById('avatar-auth-modal');
                if (modal) modal.style.display = 'flex';
            }

            closeAvatarAuthModal() {
                const modal = document.getElementById('avatar-auth-modal');
                if (modal) modal.style.display = 'none';
            }

            async grantAvatarConsent() {
                this.setAvatarConsent('granted');
                this.closeAvatarAuthModal();
                await this.ensureAvatarLoaded(true);
                this.pushHint('✅ 已授权头像展示，可点击头像更换');
                this.updateUI();
            }

            denyAvatarConsent() {
                this.setAvatarConsent('denied');
                this.closeAvatarAuthModal();
                this.pushHint('ℹ️ 已拒绝头像授权，使用默认头像');
                this.updateUI();
            }

            async loadAvatarListFromDirectory() {
                const url = `/${encodeURIComponent(this.avatarDirPath)}/`;
                const res = await fetch(url, { cache: 'no-store' });
                if (!res.ok) return [];
                const html = await res.text();
                const hrefs = Array.from(html.matchAll(/href="([^"]+)"/g)).map(m => m[1] || '');
                const files = hrefs
                    .map(h => h.split('?')[0])
                    .map(h => {
                        const parts = h.split('/').filter(Boolean);
                        return parts.length > 0 ? parts[parts.length - 1] : '';
                    })
                    .filter(h => h && h !== '..' && h !== '.')
                    .map(h => decodeURIComponent(h))
                    .filter(h => /\.(png|jpe?g|webp|gif)$/i.test(h));
                return Array.from(new Set(files));
            }

            getAvatarFile() {
                return localStorage.getItem('playerAvatarFile');
            }

            setAvatarFile(file) {
                localStorage.setItem('playerAvatarFile', file);
            }

            buildAvatarUrl(file) {
                const v = Date.now();
                return `/${encodeURIComponent(this.avatarDirPath)}/${encodeURIComponent(file)}?v=${v}`;
            }

            async ensureAvatarLoaded(forceReloadList = false) {
                if (forceReloadList || !Array.isArray(this.avatarList)) {
                    this.avatarList = await this.loadAvatarListFromDirectory();
                }
                if (!this.avatarList || this.avatarList.length === 0) return;
                const preferred = this.getAvatarFile();
                const selected = preferred && this.avatarList.includes(preferred) ? preferred : this.avatarList[0];
                await this.setAvatarByFile(selected);
            }

            async setAvatarByFile(file) {
                if (!file) return;
                const url = this.buildAvatarUrl(file);
                const ok = await new Promise(resolve => {
                    const img = new Image();
                    img.onload = () => resolve(true);
                    img.onerror = () => resolve(false);
                    img.src = url;
                });
                if (!ok) return;
                this.player.avatarUrl = url;
                this.setAvatarFile(file);
            }

            async openAvatarPicker() {
                if (this.getAvatarConsent() !== 'granted') {
                    this.openAvatarAuthModal();
                    return;
                }
                await this.ensureAvatarLoaded(true);
                const modal = document.getElementById('avatar-picker-modal');
                const listEl = document.getElementById('avatar-picker-list');
                if (!modal || !listEl) return;
                const files = Array.isArray(this.avatarList) ? this.avatarList : [];
                listEl.innerHTML = files.map(f => {
                    const u = this.buildAvatarUrl(f);
                    const encoded = encodeURIComponent(f);
                    return `<button class="avatar-pick" onclick="game.pickAvatarEncoded('${encoded}')"><img src="${u}" alt="${this.escapeHtml(f)}"></button>`;
                }).join('');
                modal.style.display = 'flex';
            }

            closeAvatarPicker() {
                const modal = document.getElementById('avatar-picker-modal');
                if (modal) modal.style.display = 'none';
            }

            async pickAvatarEncoded(encodedFile) {
                if (this.getAvatarConsent() !== 'granted') return;
                const realFile = decodeURIComponent(String(encodedFile ?? ''));
                await this.setAvatarByFile(realFile);
                this.updateUI();
                const hintText = document.getElementById('stable-hint-text');
                this.closeAvatarPicker();
            }
            
            skillEffects() {
                return {
                    '疾风': '提高移动速度，持续加成（+8%），适合直线冲刺。',
                    '爆冲': '短时间爆发速度（+15%），用于关键时刻超车。',
                    '坚韧': '耐力强化：体力消耗更慢，体力偏低时额外减耗与少量恢复。',
                    '稳健': '提升稳定与小幅速度（+5%），减少波动与失误。',
                    '灵活': '提升加速与灵敏（+5%），更快进入最佳速度区间。',
                    '神速': '显著提升最高速度，瞬间提速效果更强。',
                    '飞驰': '持续小幅速度提升，稳步拉开差距。',
                    '持久': '耐力系数提升：体力下降更慢。',
                    '回春': '体力恢复：赛中持续缓慢回复体力。',
                    '铁志': '意志加成，降低赛中抖动与速度波动。',
                    '深息': '深呼吸：跑得越久耐力越高，后程体力恢复更明显。',
                    '冷静': '抗干扰，减少外部因素造成的减速。',
                    '专注': '全程加速触发概率提升：普通+3%，稀有+5%。',
                    '草地': '草地场景专精：当场景为草地时，基础速度提高（+5%）。',
                    '平衡': '均衡型增益，速度与稳定小幅提升。',
                    '混血': '综合性加成，各项属性小幅提升。',
                    '大器': '后程爆发，最后阶段能力提升。',
                    '先锋': '前半程加速触发概率提升：普通+10%，稀有+15%。',
                    '雪地': '雪地场景专精：当场景为雪地时，基础速度提高（+5%）。',
                    '沙地': '沙地场景专精：当场景为沙地时，基础速度提高（+5%）。',
                    '天命': '神兽专属：仅神兽可激活。普通全属性+3%，稀有全属性+5%。',
                    '奇迹': '后半程加速触发概率提升：普通+10%，稀有+15%。',
                    '残影': '产生虚影，减少对手干扰判定。',
                    '流星': '终盘极速，冲线前最后加速。',
                    '传说': '史诗必带：史诗及以上可激活。普通全属性+2%，稀有全属性+4%。',
                    '混血': '普通全属性+1%，稀有全属性+3%。'
                };
            }

            skillEffectText(type) {
                const effects = this.skillEffects();
                return effects[type] || '暂无技能效果描述。';
            }

            renderReforgeSkillBox(which, genes, actives = []) {
                const listEl = document.getElementById(`reforge-${which}-list`);
                const detailEl = document.getElementById(`reforge-${which}-detail`);
                if (!listEl || !detailEl) return;

                const list = Array.isArray(genes) ? genes : [];
                const activeSet = new Set((actives || []).map(a => a.type));

                if (list.length === 0) {
                    listEl.innerHTML = '';
                    const placeholder = which === 'new' ? '点击洗练生成' : '暂无技能';
                    detailEl.innerHTML = `<div class="reforge-effect-placeholder">${this.escapeHtml(placeholder)}</div>`;
                    if (!this.reforgeSelected) this.reforgeSelected = { current: null, new: null };
                    this.reforgeSelected[which] = null;
                    return;
                }

                listEl.innerHTML = list.map(g => {
                    let cls = 'gene-normal';
                    if (g.quality === '稀有') cls = 'gene-rare';
                    else if (g.quality === '史诗') cls = 'gene-epic';
                    else if (g.quality === '神兽') cls = 'gene-legend';
                    const activeCls = activeSet.has(g.type) ? ' gene-active' : '';
                    const encoded = encodeURIComponent(g.type);
                    return `<div class="gene-tag reforge-skill-item ${cls}${activeCls}" data-skill="${this.escapeHtml(g.type)}" onclick="game.selectReforgeSkillEncoded('${which}','${encoded}')">${this.escapeHtml(g.type)}</div>`;
                }).join('');

                if (!this.reforgeSelected) this.reforgeSelected = { current: null, new: null };
                const saved = this.reforgeSelected[which];
                const next = saved && list.some(g => g.type === saved) ? saved : list[0].type;
                this.selectReforgeSkill(which, next);
            }

            selectReforgeSkillEncoded(which, encodedType) {
                const w = String(which || '');
                const type = decodeURIComponent(String(encodedType || ''));
                this.selectReforgeSkill(w, type);
            }

            selectReforgeSkill(which, type) {
                const w = which === 'current' ? 'current' : 'new';
                const listEl = document.getElementById(`reforge-${w}-list`);
                const detailEl = document.getElementById(`reforge-${w}-detail`);
                if (!listEl || !detailEl) return;
                const t = String(type || '').trim();
                if (!t) return;

                if (!this.reforgeSelected) this.reforgeSelected = { current: null, new: null };
                this.reforgeSelected[w] = t;

                const items = Array.from(listEl.querySelectorAll('.reforge-skill-item'));
                for (const el of items) {
                    const key = el.getAttribute('data-skill') || '';
                    if (key === t) el.classList.add('is-selected');
                    else el.classList.remove('is-selected');
                }

                const effect = this.skillEffectText(t);
                const badge = (w === 'new' && this.tempReforgeQuality) ? `<div class="reforge-effect-badge">新稀有等级: ${this.escapeHtml(this.tempReforgeQuality)}</div>` : '';
                detailEl.innerHTML = `
                    <div class="reforge-effect-title">${this.escapeHtml(t)}</div>
                    ${badge}
                    <div class="reforge-effect-text">${this.escapeHtml(effect)}</div>
                `;
            }
            
            showSkillDetail(type) {
                const titleEl = document.getElementById('skill-title');
                const descEl = document.getElementById('skill-desc');
                const modal = document.getElementById('skill-modal');
                const eff = this.skillEffects()[type] || '暂无该技能的详细说明';
                titleEl.innerText = `技能：${type}`;
                descEl.innerText = eff;
                modal.style.display = 'flex';
            }
            
            closeSkillModal() {
                const modal = document.getElementById('skill-modal');
                modal.style.display = 'none';
            }

            openCodex() {
                const panel = document.getElementById('codex-panel');
                const draftPanel = document.getElementById('draft-panel');
                const wasDraftOpen = !!(draftPanel && draftPanel.style && draftPanel.style.display === 'flex');
                this._returnToDraftAfterCodex = wasDraftOpen;
                if (wasDraftOpen) {
                    draftPanel.style.display = 'none';
                    this.stopDraftPreviewIdleAnim();
                }
                if (panel) panel.style.display = 'flex';
                const listEl = document.getElementById('codex-list');
                if (listEl) {
                    listEl.style.opacity = '0.35';
                    listEl.innerHTML = `<div style="color:#bdc3c7; font-size:12px; padding:8px 0; text-align:center; width:100%;">造型加载中...</div>`;
                }
                const token = (this.codexToken || 0) + 1;
                this.codexToken = token;
                const sets = Object.values(SpriteSet);
                this.prewarmHorseRunFrames(sets, [1, 2, 3]).then(() => {
                    const p = document.getElementById('codex-panel');
                    if (token !== this.codexToken) return;
                    if (!p || !(p.style && p.style.display === 'flex')) return;
                    this.renderCodex();
                });
            }

            closeCodex() {
                const panel = document.getElementById('codex-panel');
                if (panel) panel.style.display = 'none';
                this.codexToken = (this.codexToken || 0) + 1;
                if (this._returnToDraftAfterCodex) {
                    const draftPanel = document.getElementById('draft-panel');
                    if (draftPanel) draftPanel.style.display = 'flex';
                    const el = document.querySelector('#draft-selected-preview .idle-horse');
                    if (el) this.startDraftPreviewIdleAnim(el.dataset ? el.dataset.spriteSet : null);
                }
                this._returnToDraftAfterCodex = false;
            }

            renderCodex() {
                const listEl = document.getElementById('codex-list');
                if (!listEl) return;
                if (!this.player.spriteCodex || typeof this.player.spriteCodex !== 'object') this.player.spriteCodex = {};
                listEl.innerHTML = '';
                const sets = Object.values(SpriteSet);
                sets.forEach(spriteSet => {
                    const stars = Number(this.player.spriteCodex[spriteSet]) || 0;
                    const bonus = stars * 3;
                    const card = document.createElement('div');
                    card.style.cssText = 'width:135px; background:#34495e; border:1px solid #555; border-radius:10px; padding:10px; display:flex; gap:10px; align-items:center;';
                    card.innerHTML = `
                        <div class="idle-horse" style="width:54px; height:54px; --idle-scale:1.2;" data-sprite-set="${this.escapeHtml(spriteSet)}" data-idle-horse="1"></div>
                        <div style="text-align:left; flex:1; min-width:0;">
                            <div style="font-size:12px; color:#ecf0f1; font-weight:bold; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${this.escapeHtml(spriteSet)}</div>
                            <div style="font-size:10px; color:#f1c40f;">星级: ${stars}</div>
                            <div style="font-size:10px; color:#bdc3c7;">全属性加成: +${bonus}%</div>
                        </div>
                    `;
                    listEl.appendChild(card);
                    const idle = card.querySelector('.idle-horse');
                    if (idle) {
                        const preferred = Number((this.idleLastFrameBySet && this.idleLastFrameBySet[spriteSet]) || 1) || 1;
                        let idx = preferred;
                        const count = this.horseRunFrameCount(spriteSet);
                        if (!this.horseRunFrameReady(idx, spriteSet)) {
                            let found = 0;
                            for (let t = 0; t < Math.min(6, count); t++) {
                                const cand = ((idx + t - 1) % count) + 1;
                                if (this.horseRunFrameReady(cand, spriteSet)) { found = cand; break; }
                            }
                            if (found) idx = found;
                        }
                        if (this.horseRunFrameReady(idx, spriteSet)) idle.style.backgroundImage = this.horseRunFrame(idx, spriteSet);
                    }
                });
                const panel = document.getElementById('codex-panel');
                if (listEl) listEl.style.opacity = '1';
                if (panel) this.startStableIdleAnim(panel);
            }
            
            // 计算速度：基于 activeGenes (genes)
            // fullGenes：马匹已领悟的技能池，用于计算“领悟稀有技能”的基础速度加成
             computeSpeedWithGenes(baseSpeed, genes, fullGenes = [], withJitter = true, options = null) {
                 const active = Array.isArray(genes) ? genes : [];
                 const spriteSet = options && options.spriteSet ? options.spriteSet : null;
                 const applyCodex = options && options.applyCodex === true;
                 let base = Number(baseSpeed) || 0;
                 if (applyCodex) {
                    if (!this.player.spriteCodex || typeof this.player.spriteCodex !== 'object') this.player.spriteCodex = {};
                    const key = spriteSet || SpriteSet.Horse;
                    const stars = Number(this.player.spriteCodex[key]) || 0;
                    if (stars > 0) base *= (1 + stars * 0.03);
                 }

                 const hasTerrainBoost = active.some(g => g && g.type === this.sceneType && (g.type === '草地' || g.type === '雪地' || g.type === '沙地'));
                 if (hasTerrainBoost) base *= 1.05;

                 let m = 1.0;
                 active.forEach(g => {
                     const t = g.type;
                    if (t === '疾风') m += 0.08;
                    else if (t === '爆冲') m += 0.15;
                    else if (t === '坚韧') m += 0.06;
                    else if (t === '灵活') m += 0.05;
                    else if (t === '稳健') m += 0.05;
                    else if (t === '草地' || t === '雪地' || t === '沙地') {}
                    else if (t === '混血' || t === '天命' || t === '传说') {}
                    else m += 0.03; // 其他技能也有微量加成
                });

                if (active.length === 0) m *= 0.98;
                const rareSlots = active.reduce((n, g) => n + (g && g.quality === '稀有' ? 1 : 0), 0);
                const rareSlotMult = 1 + rareSlots * 0.03;
                return base * m * rareSlotMult;
             }

             computeAllAttrBoostPct(horseData, activeGenes) {
                const data = horseData || {};
                const q = data.quality || '普通';
                const list = Array.isArray(activeGenes) ? activeGenes : [];
                let sum = 0;
                const findGene = (type) => list.find(g => g && g.type === type) || null;
                const hybrid = findGene('混血');
                if (hybrid) sum += (hybrid.quality === '稀有') ? 0.03 : 0.01;
                const destiny = findGene('天命');
                if (destiny && q === '神兽') sum += (destiny.quality === '稀有') ? 0.05 : 0.03;
                const legend = findGene('传说');
                if (legend && (q === '史诗' || q === '神兽')) sum += (legend.quality === '稀有') ? 0.04 : 0.02;
                return Math.max(0, sum);
             }
            
            slotCountForHorse(h) {
                // 优先使用显式指定的槽位数
                if (h.geneSlots) return h.geneSlots;
                
                const q = h.quality;
                if (q === '稀有') return 6;
                if (q === '高级') return 5;
                if (q === '中级') return 4;
                if (q === '普通') return 3;
                return 6;
            }
            
            pickStartGenes(pool, slots) {
                if (!Array.isArray(pool) || pool.length === 0) return [];
                if (pool.length <= slots) return [...pool];
                const shuffled = [...pool].sort(() => 0.5 - Math.random());
                return shuffled.slice(0, slots);
            }
            
            ensureLockedStartGenes(h) {
                const slots = this.slotCountForHorse(h);
                const pool = Array.isArray(h.genes) ? h.genes : [];
                let locked = Array.isArray(h.lockedStartGenes) ? h.lockedStartGenes.slice(0) : [];
                const map = new Map();
                locked.forEach(g => { if (!map.has(g.type)) map.set(g.type, g); });
                let arr = Array.from(map.values());
                if (arr.length > slots) arr = arr.slice(0, slots);
                if (arr.length < slots) {
                    const remain = pool.filter(g => !arr.some(a => a.type === g.type));
                    const shuffled = [...remain].sort(() => 0.5 - Math.random());
                    arr = arr.concat(shuffled.slice(0, slots - arr.length));
                }
                h.lockedStartGenes = arr;
            }

            createNameTag(h) {
                const nameTag = document.createElement('div');
                nameTag.className = 'horse-name-tag'; // 使用新CSS类
                
                // 组装显示内容：名字 + 基因标签 (只显示 activeGenes)
                let geneHtml = '';
                if (h.activeGenes && h.activeGenes.length > 0) {
                    geneHtml = h.activeGenes.map(g => 
                        // 使用 mini-gene-tag 类
                        `<span class="mini-gene-tag" style="background:${g.quality==='普通'?'#bdc3c7':'#f1c40f'}; color:#000;">${g.type}</span>`
                    ).join('');
                }

                // 设置 HTML：第一行是名字，第二行是技能小标签
                // 修改：如果玩家马匹，名字用特殊颜色
                // 注意：这里需要判断是否是玩家的马，而不是选中的马（虽然比赛中默认选中的就是玩家参赛的马）
                // 更准确的逻辑是检查这匹马是否在玩家的 horses 列表里，但简单起见，h.id === this.selectedHorseId 通常有效，
                // 因为 startRace 会把玩家选中的马作为参赛马。
                // 不过为了支持多匹马参赛的情况（如果未来支持），最好直接判断是否是玩家控制的。
                // 目前逻辑是玩家只能派一匹选中的马。
                
                const isPlayerHorse = h && h.data && h.data.id === this.selectedHorseId;
                if (isPlayerHorse) nameTag.classList.add('is-player');
                
                nameTag.innerHTML = `
                    <div class="name-row">${this.escapeHtml(this.truncateRaceName(h.data.name))}</div>
                    <div class="skill-row">${geneHtml}</div>
                `;
                
                document.getElementById('ui-layer').appendChild(nameTag);
                h.nameTag = nameTag;
            }

             // 旧方法保留兼容 (或删除)
             computeFinalSpeed(data) { return this.computeSpeedWithGenes(data.baseSpeed, data.genes || [], data.genes || [], true, { spriteSet: data && data.spriteSet, applyCodex: true }); }

            selectHorse(id) {
                if (this.racing) return;
                this.selectedHorseId = id;
                const list = this.player && Array.isArray(this.player.horses) ? this.player.horses : [];
                const pageSize = this.stablePageSize || 4;
                const idx = list.findIndex(h => h && h.id === id);
                if (idx >= 0) this.stablePage = Math.floor(idx / pageSize);
                this.updateUI();
            }

            nextStablePage() {
                if (this.racing) return;
                const pageSize = this.stablePageSize || 4;
                const totalPages = Math.max(1, Math.ceil((this.stableCap || 8) / pageSize));
                const curr = Number(this.stablePage) || 0;
                this.stablePage = (curr + 1) % totalPages;
                this.updateUI();
            }

            promoteHorseToStableFront(horseId) {
                const id = String(horseId ?? '');
                if (!id) return;
                const list = this.player && Array.isArray(this.player.horses) ? this.player.horses : null;
                if (!list || list.length <= 1) return;
                const idx = list.findIndex(h => h && h.id === id);
                if (idx <= 0) return;
                const [horse] = list.splice(idx, 1);
                list.unshift(horse);
            }
            
            prevHorse() {
                if (this.racing) return;
                const list = this.player.horses;
                const idx = list.findIndex(h => h.id === this.selectedHorseId);
                const ni = (idx > 0 ? idx - 1 : list.length - 1);
                this.selectedHorseId = list[ni].id;
                this.updateUI();
            }
            
            nextHorse() {
                if (this.racing) return;
                const list = this.player.horses;
                const idx = list.findIndex(h => h.id === this.selectedHorseId);
                const ni = (idx < list.length - 1 ? idx + 1 : 0);
                this.selectedHorseId = list[ni].id;
                this.updateUI();
            }
            
            scrollSelectedIntoView() {
                const infoPanel = document.getElementById('info-panel');
                const rosterPanel = document.getElementById('stable-roster-panel');
                const grid = rosterPanel ? rosterPanel.querySelector('.roster-grid') : null;
                if (grid) {
                    const card = grid.querySelector('.roster-item.selected');
                    if (!card) return;
                    card.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
                    return;
                }
                const container = infoPanel.querySelector('.stable-container');
                if (!container) return;
                const card = infoPanel.querySelector('.horse-card.selected');
                if (!card) return;
                const center = card.offsetLeft + (card.offsetWidth / 2);
                const target = center - (container.clientWidth / 2);
                container.scrollTo({ left: target, behavior: 'smooth' });
            }

            retireHorse() {
                const horse = this.player.horses.find(h => h.id === this.selectedHorseId);
                if (!horse) return;
                
                if (this.player.horses.length <= 1) {
                    alert("这是你最后一匹马，不能退役！");
                    return;
                }
                
                const races = horse.totalRaces || 0;
                const refund = races * 100;
                
                if (confirm(`确定要让【${horse.name}】退役吗？\n生涯场次: ${races}\n返还积分: ${refund} (100/场)`)) {
                    if (!this.player.spriteCodex || typeof this.player.spriteCodex !== 'object') this.player.spriteCodex = {};
                    const spriteSet = horse.spriteSet || SpriteSet.Horse;
                    const nextStar = (Number(this.player.spriteCodex[spriteSet]) || 0) + 1;
                    this.player.spriteCodex[spriteSet] = nextStar;
                    this.player.integral += refund;
                    const idx = this.player.horses.indexOf(horse);
                    this.player.horses.splice(idx, 1);
                    this.selectedHorseId = this.player.horses[0].id;
                    this.updateUI();
                    alert(`退役成功！获得 ${refund} 积分。\n造型图鉴：${spriteSet} 星级 +1 (当前 ${nextStar} 星)`);
                }
            }

            startStableIdleAnim(rootEl) {
                if (this.idleAnimTimer) {
                    clearInterval(this.idleAnimTimer);
                    this.idleAnimTimer = null;
                }
                if (this.idleAnimRaf) {
                    cancelAnimationFrame(this.idleAnimRaf);
                    this.idleAnimRaf = 0;
                }
                if (this.racing) return;

                const root = rootEl || document;
                const hasAny = (root && root.querySelector && root.querySelector('.idle-horse'));
                if (!hasAny) return;
                this.stableIdleToken = (this.stableIdleToken || 0) + 1;
                const token = this.stableIdleToken;

                this.ensureHorseRunFramesReady();

                this.idleAnimLastTs = 0;
                this.idleAnimAcc = 0;
                this.idleAnimFrame = 1;

                const applyFrame = (frameIndex) => {
                    const horses = Array.from(root.querySelectorAll('.idle-horse'));
                    if (horses.length === 0) return;
                    for (const el of horses) {
                        const spriteSet = el && el.dataset ? el.dataset.spriteSet : null;
                        const count = this.horseRunFrameCount(spriteSet);
                        let idx = ((frameIndex - 1) % count) + 1;
                        if (!this.horseRunFrameReady(idx, spriteSet)) {
                            if (!el.style.backgroundImage) {
                                let found = 0;
                                for (let t = 0; t < count; t++) {
                                    const cand = ((idx + t - 1) % count) + 1;
                                    if (this.horseRunFrameReady(cand, spriteSet)) {
                                        found = cand;
                                        break;
                                    }
                                }
                                if (found) idx = found;
                                else continue;
                            } else {
                                continue;
                            }
                        }
                        el.style.backgroundImage = this.horseRunFrame(idx, spriteSet);
                        if (spriteSet) this.idleLastFrameBySet[spriteSet] = idx;
                    }
                };

                const tick = (ts) => {
                    if (token !== this.stableIdleToken) return;
                    if (this.racing) return;
                    if (root !== document && root && root.isConnected === false) return;
                    if (!this.idleAnimLastTs) this.idleAnimLastTs = ts;
                    const dt = Math.min(200, Math.max(0, ts - this.idleAnimLastTs));
                    this.idleAnimLastTs = ts;
                    this.idleAnimAcc += dt;
                    const step = 80;
                    let advanced = false;
                    while (this.idleAnimAcc >= step) {
                        this.idleAnimAcc -= step;
                        this.idleAnimFrame++;
                        if (this.idleAnimFrame > 20) this.idleAnimFrame = 1;
                        advanced = true;
                    }
                    if (advanced || !this.idleAnimRaf) applyFrame(this.idleAnimFrame);
                    this.idleAnimRaf = requestAnimationFrame(tick);
                };

                applyFrame(this.idleAnimFrame);
                this.idleAnimRaf = requestAnimationFrame(tick);
            }

            stopDraftPreviewIdleAnim() {
                if (this.draftPreviewAnimTimer) {
                    clearInterval(this.draftPreviewAnimTimer);
                    this.draftPreviewAnimTimer = null;
                }
                if (this.draftPreviewAnimRaf) {
                    cancelAnimationFrame(this.draftPreviewAnimRaf);
                    this.draftPreviewAnimRaf = 0;
                }
                this.draftPreviewToken = (this.draftPreviewToken || 0) + 1;
            }

            startDraftPreviewIdleAnim(spriteSetKey) {
                this.stopDraftPreviewIdleAnim();
                if (this.racing) return;
                const panel = document.getElementById('draft-panel');
                if (!panel || !(panel.style && panel.style.display === 'flex')) return;
                const el = document.querySelector('#draft-selected-preview .idle-horse');
                if (!el) return;
                const key = spriteSetKey || (el && el.dataset ? el.dataset.spriteSet : null) || SpriteSet.Horse;
                const token = (this.draftPreviewToken || 0) + 1;
                this.draftPreviewToken = token;
                this.ensureHorseRunFramesReady();

                this.draftPreviewLastTs = 0;
                this.draftPreviewAcc = 0;
                this.draftPreviewFrame = 1;

                const applyFrame = (frameIndex) => {
                    const node = document.querySelector('#draft-selected-preview .idle-horse');
                    if (!node) return;
                    const count = this.horseRunFrameCount(key);
                    let idx = ((frameIndex - 1) % count) + 1;
                    if (!this.horseRunFrameReady(idx, key)) {
                        if (!node.style.backgroundImage) {
                            let found = 0;
                            for (let t = 0; t < count; t++) {
                                const cand = ((idx + t - 1) % count) + 1;
                                if (this.horseRunFrameReady(cand, key)) {
                                    found = cand;
                                    break;
                                }
                            }
                            if (found) idx = found;
                            else return;
                        } else {
                            return;
                        }
                    }
                    node.style.backgroundImage = this.horseRunFrame(idx, key);
                    if (key) this.idleLastFrameBySet[key] = idx;
                };

                const tick = (ts) => {
                    if (token !== this.draftPreviewToken) return;
                    if (this.racing) return;
                    if (!panel.isConnected) return;
                    if (!this.draftPreviewLastTs) this.draftPreviewLastTs = ts;
                    const dt = Math.min(200, Math.max(0, ts - this.draftPreviewLastTs));
                    this.draftPreviewLastTs = ts;
                    this.draftPreviewAcc += dt;
                    const step = 80;
                    let advanced = false;
                    while (this.draftPreviewAcc >= step) {
                        this.draftPreviewAcc -= step;
                        this.draftPreviewFrame++;
                        if (this.draftPreviewFrame > 20) this.draftPreviewFrame = 1;
                        advanced = true;
                    }
                    if (advanced || !this.draftPreviewAnimRaf) applyFrame(this.draftPreviewFrame);
                    this.draftPreviewAnimRaf = requestAnimationFrame(tick);
                };

                applyFrame(this.draftPreviewFrame);
                this.draftPreviewAnimRaf = requestAnimationFrame(tick);
            }
            
            updateUI() {
                const p = this.player;
                const infoPanel = document.getElementById('info-panel');
                const rosterPanel = document.getElementById('stable-roster-panel');
                
                // 保留比赛中马厩滚动位置，防止刷新导致卡片跳动
                let prevScrollLeft = null;
                const prevContainer = infoPanel.querySelector('.stable-container');
                if (prevContainer) prevScrollLeft = prevContainer.scrollLeft;
                
                // 清除寿命为0的马 (改为不自动清除，允许玩家手动退役或作为种马，除非是强制逻辑)
                // 这里为了防止列表过长，还是保留自动清理寿命耗尽的逻辑，或者仅提示
                // p.horses = p.horses.filter(h => (h.lifespan == null ? true : h.lifespan > 0));
                
                if (p.horses.length === 0) {
                    // 保底：如果清空了，恢复初始第一匹以避免UI空白
                    p.horses = JSON.parse(JSON.stringify(InitialPlayer.horses));
                }
                // 保证选中ID有效
                if (!p.horses.find(h => h.id === this.selectedHorseId)) {
                    this.selectedHorseId = p.horses[0].id;
                }
                
                // 1. 生成资产行
                const races = p.seasonRaces || 0;
                const wins = p.seasonWins || 0;
                const rate = races > 0 ? Math.floor((wins / races) * 100) : 0;
                
                // 判断是否获得“赛季第一”荣誉（持续一赛季）
                // 使用 hasSeasonChampion 标记，而不是实时计算
                const isChampion = p.hasSeasonChampion;
                
                const trophyCount = p.trophies || 0;

                const avatarUrl = p.avatarUrl || '';
                const avatarCls = avatarUrl ? 'avatar has-img' : 'avatar';
                const avatarStyle = avatarUrl ? `background-image:url('${avatarUrl}');` : '';
                const avatarText = avatarUrl ? '' : '👤';

                let html = `
                    <div class="user-panel">
                        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
                            <div style="display:flex; align-items:center;">
                                <div class="avatar-wrapper" style="margin-right:10px;">
                                    <div class="${avatarCls}" style="${avatarStyle}" onclick="game.openAvatarPicker()">${avatarText}</div>
                                    ${isChampion ? `<div class="avatar-frame-gold"></div><div class="honor-crown">👑</div>` : ''}
                                </div>
                                <div>
                                    <div style="font-weight:bold; color:#fff; font-size:16px; display:flex; align-items:center; gap:6px;">
                                        马场主
                                        ${isChampion ? '<span style="color:#f1c40f; font-size:10px; background:rgba(241,196,15,0.2); padding:2px 6px; border-radius:4px;">赛季第一</span>' : ''}
                                    </div>
                                    <div style="display:flex; gap:10px; font-size:12px; color:#bdc3c7; margin-top:3px;">
                                        <span>💰 ${p.integral}</span>
                                        <span>🎫 ${p.ticketsNormal} <button style="background:none; border:none; color:#2ecc71; font-weight:bold; cursor:pointer; font-size:14px; padding:0;" onclick="game.openTicketMenu()">➕</button></span>
                                    </div>
                                    <div style="font-size:10px; margin-top:2px; display:flex; gap:8px; align-items:center;">
                                        <button class="avatar-action" onclick="game.openAvatarPicker()">更换头像</button>
                                        <button class="avatar-action" onclick="game.toggleBgm()">${this.bgmEnabled ? '关闭音乐' : '开启音乐'}</button>
                                    </div>
                                </div>
                            </div>
                            <div class="season-mini">
                                <div class="row top">
                                    <span class="season">🏆 S${this.player.seasonNo || 1}</span>
                                    <div class="mid"><span class="champ">🏆×${trophyCount}</span></div>
                                    <span>胜率 <span style="color:${rate>=40?'#2ecc71':'#e74c3c'}">${rate}%</span></span>
                                </div>
                                <div class="bar"><div style="width:${Math.min(100, (races/8)*100)}%"></div></div>
                                <div class="hint">${races >= 8 ? '✅ 已获选秀资格' : `再赛 ${8-races} 场获选秀资格`}</div>
                            </div>
                        </div>
                        <div class="stable-hint" style="margin-top:6px;">
                            <span class="shop-chip" onclick="game.openTrophyShop()">🛒 名马商店</span>
                            <div class="stable-hint-text" id="stable-hint-text">${this.escapeHtml(this.getHintText())}</div>
                        </div>
                    </div>
                    <div id="horse-detail-wrap" class="stable-panel">
                `;

                const lobby = document.getElementById('lobby-panel');
                if (lobby) {
                    const oldBtn = document.getElementById('btn-open-draft');
                    if (oldBtn) oldBtn.remove();
                    const primary = document.getElementById('btn-primary-action');
                    if (primary) {
                        if (races >= 8) {
                            primary.className = 'btn btn-orange lobby-btn';
                            primary.innerHTML = '<div class="lobby-icon">🎲</div><div class="lobby-text">参加选秀</div>';
                            primary.onclick = () => this.openDraft();
                        } else {
                            primary.className = 'btn btn-blue lobby-btn';
                            primary.innerHTML = '<div class="lobby-icon">🏠</div><div class="lobby-text">开始比赛</div>';
                            primary.onclick = () => this.startRace();
                        }
                    }
                }

                p.horses.forEach(h => {
                    this.ensureLockedStartGenes(h);
                    
                    // 获取所有技能类型，用于展示技能池，并高亮比赛使用技能
                    const allTypes = Object.values(GeneType);
                    const slots = this.slotCountForHorse(h);
                    this.ensureLockedStartGenes(h);
                    const previewActives = (h.lockedStartGenes || []).slice(0, slots);
                    const activeSet = new Set((previewActives || []).map(g => g.type));
                    const rawLearned = ([]).concat(h.learnedThisRace || [], (h.data && h.data.learnedThisRace) ? h.data.learnedThisRace : []);
                    const learnedSet = new Set(rawLearned.filter(t => !activeSet.has(t)));
                    
                    const genesHtml2 = allTypes.map(type => {
                        // 优先显示当前装备的技能 (active)，因为这决定了比赛能力
                        const activeGene = (previewActives || []).find(g => g.type === type);
                        const ownedGene = h.genes && h.genes.find(g => g.type === type);
                        
                        // 只要装备了或者拥有了，就显示
                        if (activeGene || ownedGene) {
                            // 优先使用装备的品质，其次是拥有的
                            const displayGene = activeGene || ownedGene;
                            
                            let cls = 'gene-normal';
                            if (displayGene.quality === '稀有') cls = 'gene-rare';
                            else if (displayGene.quality === '史诗') cls = 'gene-epic';
                            else if (displayGene.quality === '神兽') cls = 'gene-legend';
                            
                            const activeCls = activeSet.has(type) ? ' gene-active' : '';
                            // 如果是本次比赛新领悟的，也标记一下
                            const learnedCls = learnedSet.has(type) ? ' gene-just' : '';
                            
                            // 这里添加 stopPropagation 防止点击技能时触发马匹选择
                            return `<span class="gene-tag ${cls}${activeCls}${learnedCls}" onclick="event.stopPropagation(); game.showSkillDetail('${type}')">${type}</span>`;
                        } else {
                            return `<span class="gene-tag gene-locked" onclick="event.stopPropagation(); game.showSkillDetail('${type}')">${type}</span>`;
                        }
                    }).join('');

                    
                    const isSelected = h.id === this.selectedHorseId;
                    const selectedClass = isSelected ? 'selected' : '';

                    if (isSelected) {
                        const spriteSetKey = (h.spriteSet || SpriteSet.Horse);
                        const codexStars = Number((this.player.spriteCodex && this.player.spriteCodex[spriteSetKey]) || 0) || 0;
                        const codexBonusPct = codexStars * 3;
                        const codexMult = 1 + codexStars * 0.03;
                        const allAttrBoost = this.computeAllAttrBoostPct(h, previewActives);
                        const attrMult = codexMult * (1 + allAttrBoost);
                        const baseEndurance = Number(h.endurance) || 1.0;
                        const activeTypes = new Set((previewActives || []).map(g => g && g.type).filter(Boolean));
                        let enduranceBonus = 0;
                        if (activeTypes.has('持久')) enduranceBonus += 0.25;
                        if (activeTypes.has('坚韧')) enduranceBonus += 0.15;
                        if (activeTypes.has('深息')) enduranceBonus += 0.10;
                        const enduranceEff = (baseEndurance * attrMult) * (1 + enduranceBonus);
                        const rareSlots = (previewActives || []).reduce((n, g) => n + (g && g.quality === '稀有' ? 1 : 0), 0);
                        const rarePct = rareSlots * 3;
                        const baseSpeedWithRare = (typeof h.baseSpeed === 'number')
                            ? Math.round(h.baseSpeed * attrMult * (1 + rareSlots * 0.03))
                            : '-';
                        const staminaEff = (typeof h.stamina === 'number') ? Math.round(h.stamina * attrMult) : (h.stamina ?? '-');
                        const accelEff = (typeof h.accel === 'number') ? Number((h.accel * attrMult).toFixed(2)) : (h.accel ?? '-');
                        html += `
                            <div class="horse-card selected">
                                <div class="card-skills">
                                    <input class="horse-name-input" maxlength="12" value="${this.escapeHtml(h.name)}" onclick="event.stopPropagation()" onkeydown="event.stopPropagation(); if(event.key==='Enter'){ this.blur(); }" oninput="game.setHorseName('${h.id}', this.value)" />
                                    <div class="gene-tags" onclick="event.stopPropagation()">${genesHtml2}</div>
                                </div>
                                <div class="card-side">
                                    <div class="card-stats">
                                        <div class="stat-line"><span>稀有</span><strong>${this.escapeHtml(h.quality)}</strong></div>
                                        <div class="stat-line"><span>寿命</span><strong>${h.lifespan}/${h.maxLifespan}</strong></div>
                                        <div class="stat-line"><span>体力</span><strong>${staminaEff}</strong></div>
                                        <div class="stat-line"><span>耐力</span><strong>${enduranceEff.toFixed(2)}x</strong></div>
                                        <div class="stat-line"><span>基速</span><strong>${baseSpeedWithRare}${rareSlots > 0 ? ` (+${rarePct}%)` : ''}</strong></div>
                                        <div class="stat-line"><span>加速</span><strong>${accelEff}</strong></div>
                                        <div class="stat-line"><span>图鉴</span><strong>${codexStars}★ (+${codexBonusPct}%全属性)</strong></div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                });

                html += `</div>`;
                infoPanel.innerHTML = html;
                const codexPanel = document.getElementById('codex-panel');
                const marketPanel = document.getElementById('market-panel');
                if (codexPanel && codexPanel.style && codexPanel.style.display === 'flex') this.startStableIdleAnim(codexPanel);
                else if (marketPanel && marketPanel.style && marketPanel.style.display === 'flex') this.startStableIdleAnim(marketPanel);
                else this.startStableIdleAnim(infoPanel);
                const hintText = infoPanel.querySelector('#stable-hint-text');

                const list = p && Array.isArray(p.horses) ? p.horses : [];
                const pageSize = this.stablePageSize || 4;
                const totalPages = Math.max(1, Math.ceil((this.stableCap || 8) / pageSize));
                const currPage = Math.max(0, Math.min(totalPages - 1, Number(this.stablePage) || 0));
                this.stablePage = currPage;
                const start = currPage * pageSize;
                const end = Math.min(start + pageSize, this.stableCap || 8);
                let rosterHtml = '';
                for (let i = start; i < end; i++) {
                    const h = list[i];
                    if (h) {
                        const selectedClass = (h.id === this.selectedHorseId) ? 'selected' : '';
                        rosterHtml += `
                            <div class="roster-item ${selectedClass}" onclick="game.selectHorse('${h.id}')">
                                <div class="idle-horse" data-sprite-set="${this.escapeHtml(h.spriteSet || SpriteSet.Horse)}" data-idle-horse="1"></div>
                                <div class="roster-meta">
                                    <div class="roster-name">${this.escapeHtml(h.name)}</div>
                                    <div class="roster-sub">${this.escapeHtml(h.quality)}</div>
                                </div>
                            </div>
                        `;
                    } else {
                        rosterHtml += `
                            <div class="roster-item empty">
                                <div class="roster-meta">
                                    <div class="roster-name">空位</div>
                                    <div class="roster-sub">可容纳新马</div>
                                </div>
                            </div>
                        `;
                    }
                }

                if (rosterPanel) {
                    rosterPanel.style.display = this.racing ? 'none' : 'block';
                    const count = list.length;
                    rosterPanel.innerHTML = `
                        <div class="roster-header">
                            <div class="roster-cap">马厩 ${count}/${this.stableCap}</div>
                        </div>
                        <div class="roster-actions">
                            <button class="btn btn-blue" style="background:#c0392b; box-shadow:0 4px #922b21;" onclick="game.retireHorse()">退役<span class="sub">当前马</span></button>
                            <button class="btn btn-blue" onclick="game.nextStablePage()">翻页<span class="sub">${currPage + 1}/${totalPages}</span></button>
                        </div>
                        <div class="roster-grid">${rosterHtml}</div>
                    `;
                    this.startStableIdleAnim(rosterPanel);
                }
                
                // 比赛中恢复滚动位置
                const newContainer = infoPanel.querySelector('.stable-container');
                if (this.racing && newContainer && prevScrollLeft !== null) {
                    newContainer.scrollLeft = prevScrollLeft;
                }
                
                // 滑动手势
                const container = infoPanel.querySelector('.stable-container');
                if (container) {
                    container.style.overflowX = this.racing ? 'hidden' : 'auto';
                    let startX = 0, deltaX = 0, touching = false;
                    const onStart = (x) => { startX = x; deltaX = 0; touching = true; };
                    const onMove = (x) => { if (touching) deltaX = x - startX; };
                    const onEnd = () => {
                        if (!touching) return;
                        touching = false;
                        if (this.racing) return;
                        if (Math.abs(deltaX) > 40) {
                            if (deltaX < 0) this.nextHorse(); else this.prevHorse();
                        }
                    };
                    container.addEventListener('touchstart', e => onStart(e.touches[0].clientX), {passive:true});
                    container.addEventListener('touchmove', e => onMove(e.touches[0].clientX), {passive:true});
                    container.addEventListener('touchend', onEnd);
                    container.addEventListener('mousedown', e => onStart(e.clientX));
                    container.addEventListener('mousemove', e => onMove(e.clientX));
                    container.addEventListener('mouseup', onEnd);
                    container.addEventListener('mouseleave', onEnd);
                }
                
                // 滚动使选中项居中
                if (!this.racing) this.scrollSelectedIntoView();
            }

            openBreed() {
                document.getElementById('breed-panel').style.display = 'flex';
                document.getElementById('breed-result').innerText = '';
            }

            closeBreed() {
                document.getElementById('breed-panel').style.display = 'none';
            }

            confirmBreed() {
                // 马厩容量限制
                const count = (this.player && Array.isArray(this.player.horses)) ? this.player.horses.length : 0;
                if (count >= this.stableCap) {
                    alert(`马厩已满 (${count}/${this.stableCap})，请先退役一匹马再培育。`);
                    return;
                }
                if (this.player.integral < 500) {
                    alert("积分不足 (需要500)！先去比赛赢点分吧。");
                    return;
                }
                
                // 使用当前选中的马作为父本
                const parent1 = this.player.horses.find(h => h.id === this.selectedHorseId);
                if (!parent1) {
                    alert("请先选择一匹马！");
                    return;
                }

                if (parent1.lifespan < 10) {
                    alert("当前马匹寿命不足 10 点，无法进行培育！");
                    return;
                }

                this.player.integral -= 500;
                parent1.lifespan -= 10; // 扣除寿命
                
                const parent2 = generateAIHorse(999);
                const foal = BreedingSystem.breedHorse(parent1, parent2);
                this.player.horses.push(foal);
                
                // 自动选中新马
                this.selectedHorseId = foal.id;
                const pageSize = this.stablePageSize || 4;
                const idx = this.player.horses.findIndex(h => h && h.id === foal.id);
                if (idx >= 0) this.stablePage = Math.floor(idx / pageSize);
                
                document.getElementById('breed-result').innerText = `培育成功！获得新马：${foal.name}`;
                this.pushHint(`🎉 获得新马：${foal.name}`);
                this.updateUI();
            }

            openReforge() {
                const horse = this.player.horses.find(h => h.id === this.selectedHorseId);
                if (!horse || !horse.genes || horse.genes.length === 0) {
                    alert("该马匹没有技能，无法洗练！");
                    return;
                }
                
                document.getElementById('reforge-panel').style.display = 'flex';
                this.tempReforgeGenes = null;
                this.tempReforgeQuality = horse.quality;
                
                // 渲染当前技能
                const currentSlots = this.slotCountForHorse(horse);
                const currentLocked = Array.isArray(horse.lockedStartGenes) && horse.lockedStartGenes.length > 0
                    ? horse.lockedStartGenes.slice(0, currentSlots)
                    : this.pickStartGenes(horse.genes, currentSlots);
                this.renderReforgeSkillBox('current', currentLocked, currentLocked);
                this.renderReforgeSkillBox('new', null, null);
                
                // 按钮状态
                document.getElementById('btn-do-reforge').style.display = 'block';
                document.getElementById('btn-save-reforge').style.display = 'none';
                const discardBtn = document.getElementById('btn-discard-reforge');
                if (discardBtn) discardBtn.style.display = 'none';
            }

            closeReforge() {
                document.getElementById('reforge-panel').style.display = 'none';
                this.tempReforgeGenes = null;
                this.tempReforgeQuality = null;
            }

            renderReforgeGenes(genes, containerId, actives = []) {
                const id = String(containerId || '');
                if (id.includes('current')) this.renderReforgeSkillBox('current', genes, actives);
                else this.renderReforgeSkillBox('new', genes, actives);
            }

            doReforge() {
                const horse = this.player.horses.find(h => h.id === this.selectedHorseId);
                
                // 概率提升稀有等级：普通->中级->高级->稀有
                const ladder = ['普通','中级','高级','稀有'];
                let q = horse.quality;
                const idx = ladder.indexOf(q);
                if (idx !== -1 && idx < ladder.length - 1) {
                    if (Math.random() < 0.3) { // 30% 升一级
                        q = ladder[idx + 1];
                    }
                }
                this.tempReforgeQuality = q;
                
                // 根据新等级的槽位，生成全新的技能组合
                // 修改：洗练只能从已激活的技能池 (horse.genes) 中选择，不能凭空生成新技能
                // 但洗练可以尝试提升已拥有技能的稀有度（或者保持原样，这里假设只改变组合，不改变池子里的稀有度）
                // 需求是：只能洗出已经激活的技能。
                // 那么逻辑是：从 horse.genes 里随机挑 slots 个出来。
                // 如果 horse.genes 数量不够 slots，则重复选或者填满为止。
                
                const slots = (() => {
                    // 计算新稀有度对应的槽位数
                    // 如果发生了突破（稀有度提升），且当前槽位少于新稀有度的标准槽位，则增加槽位
                    if (q !== horse.quality) {
                        const standardSlots = this.slotCountForHorse({ quality: q }); // 不传 geneSlots 获取标准值
                        if ((horse.geneSlots || 0) < standardSlots) {
                            return standardSlots;
                        }
                    }
                    return this.slotCountForHorse({ quality: q, geneSlots: horse.geneSlots });
                })();
                const pool = horse.genes || [];
                
                if (pool.length === 0) {
                    alert("当前马匹没有已激活的技能，无法洗练！请先去比赛领悟技能。");
                    // 恢复状态
                    this.tempReforgeQuality = null;
                    return;
                }

                const newGenes = [];
                // 简单的随机抽取（允许重复选？通常不允许，除非池子太小）
                // 假设池子不够时，只能选这么多
                
                // 深拷贝池子以供抽取
                let available = JSON.parse(JSON.stringify(pool));
                
                // 如果池子比槽位小，直接全选，不够的部分空着（或者允许重复？游戏通常不允许重复装备同一技能）
                // 这里我们逻辑是：如果池子小，就全上。
                // 如果池子大，就随机选。
                
                // 为了增加洗练的意义，我们允许在这里“重随”技能的排列组合
                // 至于稀有度：应该继承池子里的稀有度，还是允许洗练提升？
                // 用户说“洗练只能洗出技能池里已经激活的技能”，通常暗示只是改变“装备配置”。
                // 但之前的需求是“洗练能出神兽”，现在既然限制了池子，那神兽只能是池子里本来就有的。
                // 所以这里严格遵循：只从池子里拿。
                
                // 乱序
                available.sort(() => 0.5 - Math.random());
                
                // 取前 slots 个
                for(let i=0; i<slots; i++) {
                    if (i < available.length) {
                        newGenes.push(available[i]);
                    }
                }
                
                this.tempReforgeGenes = newGenes;
                
                // 渲染新技能
                this.renderReforgeSkillBox('new', this.tempReforgeGenes, this.tempReforgeGenes);
                
                // 切换按钮
                document.getElementById('btn-do-reforge').style.display = 'none';
                document.getElementById('btn-save-reforge').style.display = 'block';
                const discardBtn = document.getElementById('btn-discard-reforge');
                if (discardBtn) discardBtn.style.display = 'block';
            }
            
            saveReforge() {
                if (!this.tempReforgeGenes) return;
                
                const horse = this.player.horses.find(h => h.id === this.selectedHorseId);
                horse.lockedStartGenes = this.tempReforgeGenes;
                if (this.tempReforgeQuality) {
                    horse.quality = this.tempReforgeQuality;
                    // 同步 geneSlots：如果新稀有度支持更多槽位，则扩充
                    const standardSlots = this.slotCountForHorse({ quality: horse.quality });
                    if (!horse.geneSlots || horse.geneSlots < standardSlots) {
                        horse.geneSlots = standardSlots;
                    }
                    
                    // 修复：升级稀有度时，必须同步提升基础速度，否则无法跑赢同级 AI
                    const speedMap = {'普通':55, '中级':60, '高级':65, '稀有':70, '神兽':75};
                    if (speedMap[horse.quality] > horse.baseSpeed) {
                        horse.baseSpeed = speedMap[horse.quality];
                    }
                }
                
                // 将洗练出的新技能合并入技能池 (可选：如果希望洗练也能拓充图鉴)
                // 修改：只有领悟可以激活技能池，洗练技能只能替换比赛中默认技能
                // 因此这里不再合并到 horse.genes
                /* 
                if (horse.genes) {
                    this.tempReforgeGenes.forEach(newG => {
                        // ...
                    });
                }
                */
                
                this.ensureLockedStartGenes(horse);
                this.ensureLockedStartGenes(horse);
                alert("保存成功！");
                this.closeReforge();
                this.updateUI();
            }
            
            discardReforge() {
                // 放弃洗练：清空预览，恢复按钮
                this.tempReforgeGenes = null;
                this.tempReforgeQuality = null;
                this.renderReforgeSkillBox('new', null, null);
                document.getElementById('btn-do-reforge').style.display = 'block';
                document.getElementById('btn-save-reforge').style.display = 'none';
                const discardBtn = document.getElementById('btn-discard-reforge');
                if (discardBtn) discardBtn.style.display = 'none';
            }

            openTicketMenu() {
                const modal = document.getElementById('ticket-modal');
                const count = document.getElementById('ticket-modal-count');
                if (modal && count) {
                    count.innerText = this.player.ticketsNormal;
                    modal.style.display = 'flex';
                }
            }

            closeTicketMenu() {
                const modal = document.getElementById('ticket-modal');
                if (modal) modal.style.display = 'none';
            }

            buyTicketWithPoints() {
                if (this.player.integral >= 200) {
                    this.player.integral -= 200;
                    this.player.ticketsNormal += 1;
                    this.updateUI();
                    // 更新弹窗内的数量
                    const count = document.getElementById('ticket-modal-count');
                    if (count) count.innerText = this.player.ticketsNormal;
                    alert("购买成功！门票 +1 (消耗200积分)");
                } else {
                    alert("积分不足！需要 200 积分。");
                }
            }
            
            watchAdForTicket() {
                 // 模拟看广告 3秒 (Modal版)
                const btn = document.getElementById('btn-watch-ad-modal');
                if (!btn) return;
                
                const originalText = "📺 观看广告 (免费+5)";
                btn.disabled = true;
                btn.innerText = "📺 观看中 (3s)...";
                
                setTimeout(() => {
                    this.player.ticketsNormal += 5;
                    this.updateUI();
                    
                    // 更新弹窗内的数量
                    const count = document.getElementById('ticket-modal-count');
                    if (count) count.innerText = this.player.ticketsNormal;
                    
                    alert("观看完毕！门票 +5");
                    btn.disabled = false;
                    btn.innerText = originalText;
                }, 3000);
            }

            watchAd() {
                // 模拟看广告 3秒
                const btn = document.getElementById('btn-watch-ad');
                const originalText = btn.innerText;
                btn.disabled = true;
                btn.innerText = "📺 观看中 (3s)...";
                
                setTimeout(() => {
                    this.player.ticketsNormal += 5;
                    alert("观看完毕！门票 +5");
                    btn.disabled = false;
                    btn.innerText = originalText;
                    this.updateUI();
                }, 3000);
            }

            async startRace() {
                this.tryStartBgm();
                if (this.player.seasonRaces >= 8) {
                    alert("本赛季已结束（8场）！请点击上方【参加选秀】进入选秀大会开启新赛季。");
                    return;
                }

                if (this.player.ticketsNormal < 1) {
                    alert("门票不足！请观看广告获取。");
                    return;
                }
                
                // 使用当前选中的马参赛
                const myHorse = this.player.horses.find(h => h.id === this.selectedHorseId);
                
                if (myHorse.lifespan <= 0) {
                    alert("当前选中的马匹寿命已尽！请选择其他马匹。");
                    return;
                }

                const btn = document.getElementById('btn-primary-action');
                if (btn) btn.disabled = true;
                const hasScene = !!this._sceneTileDataUrl;
                const isPreloadingScene = !!this._preloadNextScenePromise;
                const sceneReady = this._preloadNextScenePromise
                    ? this._preloadNextScenePromise
                    : (hasScene ? Promise.resolve(true) : Promise.resolve().then(() => {
                        this.selectRandomScene();
                        return this.prepareSceneTile();
                    }));
                this.openSceneTransition((hasScene || isPreloadingScene) ? '准备开赛' : '加载地图', (hasScene || isPreloadingScene) ? '正在进入赛道...' : '正在准备赛道...');
                const assetsReady = Promise.all([
                    this.ensureHorseRunFramesReady(),
                    this.ensureBurstFramesReady(),
                    this.ensureJifengFramesReady(),
                    this.ensureLanyingFramesReady(),
                    this.ensureLieyanFramesReady(),
                    this.ensureRuneEffectsFramesReady()
                ]);
                await Promise.all([sceneReady, assetsReady, new Promise(r => setTimeout(r, 260))]);
                this.setSceneTransitionFadeMode(true);
                await this.waitFrames(1);

                // 切换到比赛模式
                document.getElementById('game-container').classList.add('racing-mode');

                this.player.ticketsNormal--;
                myHorse.lifespan--;
                this.updateUI();

                this.currentRaceHorseId = myHorse.id;

                document.getElementById('lobby-panel').style.display = 'none';
                document.getElementById('status-label').style.display = 'none';
                if (btn) btn.disabled = false;

                // 生成马匹：一共3组，每组6匹，共18匹
                this.allGroups = [];
                this.horses = []; // 仅存储当前视觉展示组（玩家所在组）
                this.finishCounter = 0;
                
                // 1. 准备所有参赛马匹 (1 Player + 17 AI)
                const allParticipants = [myHorse];
                for(let i=0; i<17; i++) {
                    allParticipants.push(generateAIHorse(i, this.player, myHorse));
                }
                
                // 2. 随机打乱并分组
                // Fisher-Yates Shuffle
                for (let i = allParticipants.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allParticipants[i], allParticipants[j]] = [allParticipants[j], allParticipants[i]];
                }
                
                // 分3组，每组6匹
                const groupNames = ['A', 'B', 'C'];
                for(let g=0; g<3; g++) {
                    const groupHorses = allParticipants.slice(g*6, (g+1)*6);
                    this.allGroups.push({
                        name: groupNames[g] + ' 组',
                        data: groupHorses
                    });
                }
                
                // 3. 找到玩家所在的组，作为视觉展示组
                let playerGroupIndex = this.allGroups.findIndex(g => g.data.some(h => h.id === myHorse.id));
                const visualGroupData = this.allGroups[playerGroupIndex].data;
                this.playerGroupIndex = playerGroupIndex;
                
                // 显示分组信息提示
                const groupMsg = document.createElement('div');
                groupMsg.style.cssText = 'position:absolute; top:60px; left:50%; transform:translateX(-50%); color:#f1c40f; font-weight:bold; font-size:24px; text-shadow:0 0 5px #000; z-index:100; pointer-events:none; opacity:0; transition:opacity 0.5s;';
                groupMsg.innerText = `当前进行: ${this.allGroups[playerGroupIndex].name}`;
                document.getElementById('game-container').appendChild(groupMsg);
                
                // 动画显示
                requestAnimationFrame(() => groupMsg.style.opacity = '1');
                setTimeout(() => {
                    groupMsg.style.opacity = '0';
                    setTimeout(() => groupMsg.remove(), 500);
                }, 2000);
                
                const track = document.getElementById('track-layer'); // 修复：重新定义 track 变量
                
                // 添加跑道分隔线 (横向)
                track.innerHTML = '';
                const marks = document.createElement('div');
                marks.className = 'track-marks';
                track.appendChild(marks);
                this.trackMarksEl = marks;
                const finishLine = document.createElement('div');
                finishLine.className = 'finish-line';
                finishLine.style.left = (50 + 2000) + 'px';
                track.appendChild(finishLine);
                // 跑道总高度约 667 - 250 = 417px
                // 5条跑道，每条约 80px
                
                // 初始化马匹比赛数据 (仅初始化玩家所在组)
                visualGroupData.forEach((data, i) => {
                    // 如果是 AI 马（id以ai_开头），需要根据当前赛季场次，适当加强一点（模拟 AI 也在成长）
                    // 已经在 generateAIHorse 里做了一部分，这里确保 AI 也能带上技能
                    if (data.id.startsWith('ai_')) {
                        // AI 自动配技能：根据玩家当前马匹的技能数量动态调整
                        // 确保 AI 技能数量不超过玩家
                        const slots = this.slotCountForHorse(data);
                        const playerSkillCount = myHorse.genes ? myHorse.genes.length : 0;
                        
                        if (!data.genes || data.genes.length === 0) {
                            // 限制 AI 技能数：直接对齐玩家技能数，且不能超过自身槽位
                            let count = Math.min(playerSkillCount, slots);
                            const baseTypes = allowedGeneTypesForQuality(data.quality);
                            const filteredPool = baseTypes.map(t => ({ type: t, quality: '普通' }));
                            data.genes = this.pickStartGenes(filteredPool, count);
                            if (data.quality === '神兽' && !data.genes.some(g => g && g.type === '天命')) {
                                if (data.genes.length > 0) data.genes[Math.floor(Math.random() * data.genes.length)].type = '天命';
                                else data.genes = [{ type: '天命', quality: '普通' }];
                            }
                            if (data.quality === '史诗' && !data.genes.some(g => g && g.type === '传说')) {
                                if (data.genes.length > 0) data.genes[Math.floor(Math.random() * data.genes.length)].type = '传说';
                                else data.genes = [{ type: '传说', quality: '普通' }];
                            }
                        }
                    }

                    this.ensureLockedStartGenes(data);
                    const el = document.createElement('div');
                    el.className = 'horse';
                    el.dataset.spriteSet = data.spriteSet || SpriteSet.Horse;
                    const raceScale = RaceSpriteScale[el.dataset.spriteSet] || 1;
                    el.style.setProperty('--race-scale', String(raceScale));
                    const startFrame = ((i * 4) % 20) + 1;
                    el.style.backgroundImage = this.horseRunFrame(startFrame, data.spriteSet);
                    // 调整赛马垂直位置：增加间距，整体下移
                    // 改为6匹马，间距调整为 90px，起始 40px
                    const baseTop = i * 90 + 40;
                    el.style.top = baseTop + 'px'; 
                    el.style.left = '50px';
                    track.appendChild(el);

                    const isMythicalLegendary = data && data.quality === '神兽' && (data.spriteSet || SpriteSet.Horse) === SpriteSet.Legendary;
                    let jifengEl = null;
                    if (isMythicalLegendary) {
                        const fx = document.createElement('div');
                        fx.className = 'horse-jifeng';
                        fx.style.top = Math.round((baseTop + 74) - (170 / 2)) + 'px';
                        fx.style.left = '-9999px';
                        fx.style.setProperty('--race-scale', String(raceScale));
                        const list = this.jifengFrameCss && this.jifengFrameCss.jifeng;
                        if (Array.isArray(list) && list[1]) fx.style.backgroundImage = list[1];
                        track.appendChild(fx);
                        jifengEl = fx;
                    }

                    const isMythicalLegendary2 = data && data.quality === '神兽' && (data.spriteSet || SpriteSet.Horse) === SpriteSet.Legendary2;
                    let lanyingEl = null;
                    if (isMythicalLegendary2) {
                        const fx = document.createElement('div');
                        fx.className = 'horse-lanying';
                        fx.style.top = Math.round((baseTop + 74) - (170 / 2)) + 'px';
                        fx.style.left = '-9999px';
                        fx.style.setProperty('--race-scale', String(raceScale));
                        const list = this.lanyingFrameCss && this.lanyingFrameCss.lanying;
                        if (Array.isArray(list) && list[1]) fx.style.backgroundImage = list[1];
                        track.appendChild(fx);
                        lanyingEl = fx;
                    }

                    const isMythicalLegendary3 = data && data.quality === '神兽' && (data.spriteSet || SpriteSet.Horse) === SpriteSet.Legendary3;
                    let lieyanEl = null;
                    if (isMythicalLegendary3) {
                        const fx = document.createElement('div');
                        fx.className = 'horse-lieyan';
                        fx.style.top = Math.round((baseTop + 74) - (175 / 2)) + 'px';
                        fx.style.left = '-9999px';
                        fx.style.setProperty('--race-scale', String(raceScale));
                        const list = this.lieyanFrameCss && this.lieyanFrameCss.lieyan;
                        if (Array.isArray(list) && list[1]) fx.style.backgroundImage = list[1];
                        track.appendChild(fx);
                        lieyanEl = fx;
                    }
                     
                     // 比赛初始技能：根据稀有等级的槽位数，从技能池锁定
                     // 清空当局的“新领悟”标记
                     data.learnedThisRace = [];
                     const slots = this.slotCountForHorse(data);
                     const activeGenes = (data.lockedStartGenes || []).slice(0, slots);
                     data.activeGenes = activeGenes;
                     const hasTerrainBoost = activeGenes.some(g => g && g.type === this.sceneType);
                     let dustEl = null;
                     if (hasTerrainBoost) {
                        const fx = document.createElement('div');
                        fx.className = 'horse-dust';
                        fx.style.top = '-9999px';
                        fx.style.left = '-9999px';
                        fx.style.setProperty('--race-scale', String(raceScale));
                        const list = this.runeffectsFrameCss && this.runeffectsFrameCss.dust;
                        if (Array.isArray(list) && list[1]) fx.style.backgroundImage = list[1];
                        track.appendChild(fx);
                        dustEl = fx;
                     }
                     const isPlayerOwned = Array.isArray(this.player.horses) && this.player.horses.some(h => h && h.id === data.id);
                     const allAttrBoost = this.computeAllAttrBoostPct(data, activeGenes);
                     const baseSpeedEff = this.computeSpeedWithGenes((Number(data.baseSpeed) || 0) * (1 + allAttrBoost), activeGenes, data.genes, true, { spriteSet: (data.spriteSet || SpriteSet.Horse), applyCodex: isPlayerOwned });
                     let codexMult = 1;
                     if (isPlayerOwned) {
                        if (!this.player.spriteCodex || typeof this.player.spriteCodex !== 'object') this.player.spriteCodex = {};
                        const key = (data.spriteSet || SpriteSet.Horse);
                        const stars = Number(this.player.spriteCodex[key]) || 0;
                        codexMult = 1 + stars * 0.03;
                     }
                     const attrMult = codexMult * (1 + allAttrBoost);
                     const staminaMax = (Number(data.stamina) || 70) * attrMult;
                     const enduranceBase = (Number(data.endurance) || 1.0) * attrMult;
                     const accelEff = (Number(data.accel) || 0.8) * attrMult;

                     this.horses.push({ 
                         el, 
                         nameTag: null, 
                         data, // 引用原始数据 (用于赛后保存)
                         activeGenes, // 当局生效的技能 (6个基础 + 1个领悟)
                         distance: 0, 
                         baseSpeedEff,
                        speed: baseSpeedEff,
                        finished: false,
                        finishPlace: null,
                        staminaMax,
                        staminaNow: staminaMax,
                        enduranceBase,
                        accelEff,
                        boostCooldown: 0,
                        boostMult: 0,
                        markNextAt: 28 + Math.random() * 22,
                        markKind: 'hoof',
                         frameIndex: startFrame,
                        frameTimer: (i % 4),
                        baseTop: baseTop,
                        _learned: false, 
                        boostTimer: 0,
                        afterimageTimer: 0,
                        burstCooldown: 0,
                        jifengEl,
                        jifengFrameIndex: 1,
                        jifengFrameTimer: (i % 4),
                        lanyingEl,
                        lanyingFrameIndex: 1,
                        lanyingFrameTimer: (i % 4),
                        lieyanEl,
                        lieyanFrameIndex: 1,
                        lieyanFrameTimer: (i % 4),
                        ghostCooldown: 0,
                        _prevSpeed: null,
                        debuffTimer: 0,
                        raceScale,
                        dustEl,
                        dustFrameIndex: 1,
                        dustFrameTimer: (i % 3),
                        dustLife: hasTerrainBoost ? -1 : 0
                     });
                 });

                // 生成名牌
                this.horses.forEach(h => {
                     this.createNameTag(h);
                });

                // 重置跑道位置
                track.style.left = '0px'; // 横向重置
                track.style.top = '0px';

                await this.waitFrames(2);
                const trackContainer = document.getElementById('track-container');
                if (trackContainer) await this.waitTransitionEnd(trackContainer, 'top', 900);
                await this.closeSceneTransition();
                await this.waitFrames(1);
                this.racing = true;
                requestAnimationFrame(this.loop.bind(this));
            }

            spawnGhost(h, intensity = 1) {
                const track = document.getElementById('track-layer');
                const ghost = document.createElement('div');
                ghost.className = 'horse-ghost';
                ghost.style.top = h.baseTop + 'px';
                ghost.style.left = (Math.round(50 + h.distance) - 20) + 'px';
                ghost.style.backgroundImage = h.el.style.backgroundImage;
                ghost.dataset.spriteSet = h.data?.spriteSet || SpriteSet.Horse;
                const raceScale = h.raceScale || RaceSpriteScale[ghost.dataset.spriteSet] || 1;
                ghost.style.setProperty('--race-scale', String(raceScale));
                const baseOpacity = 0.26 * Math.max(0.4, Math.min(1.6, intensity));
                track.appendChild(ghost);
                let op = baseOpacity, dx = 0;
                const anim = () => {
                    dx += 1.5;
                    op -= 0.04;
                    ghost.style.transform = `translateZ(0) scaleX(-1) scale(${raceScale}) translateX(-${dx}px)`;
                    ghost.style.opacity = String(op);
                    if (op > 0) requestAnimationFrame(anim);
                    else if (ghost.parentNode) ghost.parentNode.removeChild(ghost);
                };
                requestAnimationFrame(anim);
            }

            spawnBurst(h, intensity = 1) {
                const list = this.burstFrameCss && this.burstFrameCss.chixiao;
                const imgs = this.burstImages && this.burstImages.chixiao;
                if (!Array.isArray(list) || list.length < 2) return;

                const track = document.getElementById('track-layer');
                const burst = document.createElement('div');
                burst.className = 'horse-burst';
                burst.style.top = (h.baseTop - 20) + 'px';
                burst.style.left = (Math.round(50 + h.distance) - 70) + 'px';
                burst.style.setProperty('--race-scale', String(h.raceScale || 1));
                burst.style.backgroundImage = list[1];
                track.appendChild(burst);

                let op = 0.9 * Math.max(0.6, Math.min(1.4, intensity));
                let frame = 1;
                let tick = 0;
                let dx = 0;
                const anim = () => {
                    tick++;
                    dx += 1.8;
                    op -= 0.06;
                    if (tick % 2 === 0) {
                        const next = frame >= 3 ? 3 : (frame + 1);
                        const img = imgs && imgs[next];
                        if (img && img.complete && img.naturalWidth > 0) {
                            frame = next;
                            burst.style.backgroundImage = list[frame];
                        }
                    }
                    burst.style.opacity = String(Math.max(0, op));
                    burst.style.transform = `translateZ(0) scaleX(-1) scale(${h.raceScale || 1}) translateX(-${dx}px)`;
                    if (op > 0) requestAnimationFrame(anim);
                    else if (burst.parentNode) burst.parentNode.removeChild(burst);
                };
                requestAnimationFrame(anim);
            }

            spawnTrackMark(h, x, y) {
                const layer = this.trackMarksEl || document.querySelector('#track-layer .track-marks');
                if (!layer) return;
                const isCircle = h && h.markKind === 'circle';
                const alt = !!(h && (h._markAlt = !h._markAlt));
                const makeOne = (dx, dy, rotMul) => {
                    const mark = document.createElement('div');
                    mark.className = isCircle ? 'track-mark circle' : 'track-mark';
                    mark.style.left = Math.round(x + dx) + 'px';
                    mark.style.top = Math.round(y + dy) + 'px';
                    const rot = (-16 + Math.random() * 32) * (rotMul || 1);
                    const s = 0.95 + Math.random() * 0.35;
                    const op = 0.34 + Math.random() * 0.14;
                    mark.style.setProperty('--rot', rot + 'deg');
                    mark.style.setProperty('--s', String(s));
                    mark.style.setProperty('--op', String(op));
                    layer.appendChild(mark);
                    const rm = () => { if (mark.parentNode) mark.parentNode.removeChild(mark); };
                    mark.addEventListener('animationend', rm, { once: true });
                    setTimeout(rm, 2600);
                };
                if (isCircle) {
                    makeOne(0, 0, 1);
                } else {
                    const sway = alt ? -1 : 1;
                    makeOne(-3, sway * 1, 1);
                    makeOne(3, -sway * 1, -1);
                }
                const max = Number(this.trackMarksMax) || 420;
                if (layer.childElementCount > max) {
                    const overflow = layer.childElementCount - max;
                    for (let i = 0; i < overflow; i++) {
                        const n = layer.firstElementChild;
                        if (!n) break;
                        layer.removeChild(n);
                    }
                }
            }

            loop() {
                if (!this.racing) return;

                let finishedCount = 0;
                let playerHorse = this.horses[0];
                const uiLayer = document.getElementById('ui-layer');
                const finishDist = 2000;
                
                this.horses.forEach(h => {
                    const prevSpeed = h._prevSpeed ?? h.speed;
                    const prevDist = h.distance;
                    const enableBurstFx = true;
                    const enableGhostFx = true;

                    if (h.dustEl) {
                        const fxLife = Number(h.dustLife) || 0;
                        if (fxLife === 0) {
                            if (h.dustEl.parentNode) h.dustEl.parentNode.removeChild(h.dustEl);
                            h.dustEl = null;
                        } else {
                            const dustW = 110;
                            const dustH = 70;
                            const baseLeft = Math.round(50 + h.distance);
                            const left = Math.round(baseLeft - 34);
                            const top = Math.round(h.baseTop + 120 - dustH - 8);
                            h.dustEl.style.left = left + 'px';
                            h.dustEl.style.top = top + 'px';
                            const alpha = fxLife < 0 ? 0.9 : Math.max(0, Math.min(0.9, fxLife / 120 * 0.9));
                            h.dustEl.style.opacity = String(alpha);
                            h.dustFrameTimer++;
                            if (h.dustFrameTimer > 1) {
                                const list = this.runeffectsFrameCss && this.runeffectsFrameCss.dust;
                                const imgs = this.runeffectsImages && this.runeffectsImages.dust;
                                const frameCount = Math.max(1, (list ? (list.length - 1) : 1));
                                const next = (h.dustFrameIndex >= frameCount ? 1 : (h.dustFrameIndex + 1));
                                const img = imgs && imgs[next];
                                if (img && img.complete && img.naturalWidth > 0 && list && list[next]) {
                                    h.dustFrameIndex = next;
                                    h.dustEl.style.backgroundImage = list[next];
                                }
                                h.dustFrameTimer = 0;
                            }
                            if (fxLife > 0) h.dustLife = fxLife - 1;
                        }
                    }

                    if (h.jifengEl) {
                        const anchorX = 50 + h.distance + 60;
                        const anchorY = h.baseTop + 74;
                        h.jifengEl.style.left = Math.round(anchorX - (170 / 2)) + 'px';
                        h.jifengEl.style.top = Math.round(anchorY - (170 / 2)) + 'px';
                        h.jifengFrameTimer++;
                        if (h.jifengFrameTimer > 2) {
                            const frameCount = Math.max(1, ((this.jifengFrameCss && this.jifengFrameCss.jifeng) ? (this.jifengFrameCss.jifeng.length - 1) : 1));
                            const next = (h.jifengFrameIndex >= frameCount ? 1 : (h.jifengFrameIndex + 1));
                            const imgs = this.jifengImages && this.jifengImages.jifeng;
                            const list = this.jifengFrameCss && this.jifengFrameCss.jifeng;
                            const img = imgs && imgs[next];
                            if (img && img.complete && img.naturalWidth > 0 && list && list[next]) {
                                h.jifengFrameIndex = next;
                                h.jifengEl.style.backgroundImage = list[next];
                            }
                            h.jifengFrameTimer = 0;
                        }
                    }

                    if (h.lanyingEl) {
                        const anchorX = 50 + h.distance + 60;
                        const anchorY = h.baseTop + 74;
                        h.lanyingEl.style.left = Math.round(anchorX - (170 / 2)) + 'px';
                        h.lanyingEl.style.top = Math.round(anchorY - (170 / 2)) + 'px';
                        h.lanyingFrameTimer++;
                        if (h.lanyingFrameTimer > 2) {
                            const frameCount = Math.max(1, ((this.lanyingFrameCss && this.lanyingFrameCss.lanying) ? (this.lanyingFrameCss.lanying.length - 1) : 1));
                            const next = (h.lanyingFrameIndex >= frameCount ? 1 : (h.lanyingFrameIndex + 1));
                            const imgs = this.lanyingImages && this.lanyingImages.lanying;
                            const list = this.lanyingFrameCss && this.lanyingFrameCss.lanying;
                            const img = imgs && imgs[next];
                            if (img && img.complete && img.naturalWidth > 0 && list && list[next]) {
                                h.lanyingFrameIndex = next;
                                h.lanyingEl.style.backgroundImage = list[next];
                            }
                            h.lanyingFrameTimer = 0;
                        }
                    }

                    if (h.lieyanEl) {
                        const anchorX = 50 + h.distance + 60;
                        const anchorY = h.baseTop + 74;
                        h.lieyanEl.style.left = Math.round(anchorX - (175 / 2)) + 'px';
                        h.lieyanEl.style.top = Math.round(anchorY - (175 / 2)) + 'px';
                        h.lieyanFrameTimer++;
                        if (h.lieyanFrameTimer > 2) {
                            const frameCount = Math.max(1, ((this.lieyanFrameCss && this.lieyanFrameCss.lieyan) ? (this.lieyanFrameCss.lieyan.length - 1) : 1));
                            const next = (h.lieyanFrameIndex >= frameCount ? 1 : (h.lieyanFrameIndex + 1));
                            const imgs = this.lieyanImages && this.lieyanImages.lieyan;
                            const list = this.lieyanFrameCss && this.lieyanFrameCss.lieyan;
                            const img = imgs && imgs[next];
                            if (img && img.complete && img.naturalWidth > 0 && list && list[next]) {
                                h.lieyanFrameIndex = next;
                                h.lieyanEl.style.backgroundImage = list[next];
                            }
                            h.lieyanFrameTimer = 0;
                        }
                    }

                    // 更新动画帧
                    h.frameTimer++;
                    if (h.frameTimer > 3) { 
                        const nextFrame = (h.frameIndex >= 20 ? 1 : (h.frameIndex + 1));
                        const spriteSetKey = (h.data && h.data.spriteSet) ? h.data.spriteSet : SpriteSet.Horse;
                        const key = (spriteSetKey && this.horseRunFrameCss && this.horseRunFrameCss[spriteSetKey]) ? spriteSetKey : SpriteSet.Horse;
                        const img = this.horseRunImages && this.horseRunImages[key] && this.horseRunImages[key][nextFrame];
                        if (img && img.complete && img.naturalWidth > 0) {
                            h.frameIndex = nextFrame;
                            h.el.style.backgroundImage = this.horseRunFrameCss[key][nextFrame];
                        }
                        h.frameTimer = 0;
                    }

                    const activeTypes = new Set((h.activeGenes || []).map(g => g && g.type).filter(Boolean));
                    const staminaMax = Number(h.staminaMax) || 70;
                    const staminaNow = Number(h.staminaNow);
                    const baseEndurance = Number(h.enduranceBase) || 1.0;
                    const accelStat = Number(h.accelEff) || (Number(h.data && h.data.accel) || 0.8);
                    let enduranceBonus = 0;
                    if (activeTypes.has('持久')) enduranceBonus += 0.25;
                    if (activeTypes.has('坚韧')) enduranceBonus += 0.15;
                    if (activeTypes.has('深息')) enduranceBonus += 0.10 + 0.20 * Math.min(1, h.distance / 2000);
                    const enduranceEff = baseEndurance * (1 + enduranceBonus);

                    if (!h.finished && h.distance < finishDist) {
                        if (h.boostCooldown && h.boostCooldown > 0) h.boostCooldown--;

                        const currStamina = Number.isFinite(staminaNow) ? staminaNow : staminaMax;
                        const canAccel = currStamina >= 30;
                        if ((h.boostTimer || 0) <= 0 && (!h.boostCooldown || h.boostCooldown <= 0) && canAccel) {
                            const startHalf = (Number(h.distance) || 0) <= (finishDist * 0.5);
                            const endHalf = (Number(h.distance) || 0) >= (finishDist * 0.5);
                            let bonusChance = 0;
                            const earlyBird = (h.activeGenes || []).find(g => g && g.type === '先锋') || null;
                            if (earlyBird && startHalf) bonusChance += (earlyBird.quality === '稀有') ? 0.15 : 0.10;
                            const focusGene = (h.activeGenes || []).find(g => g && g.type === '专注') || null;
                            if (focusGene) bonusChance += (focusGene.quality === '稀有') ? 0.05 : 0.03;
                            const miracle = (h.activeGenes || []).find(g => g && g.type === '奇迹') || null;
                            if (miracle && endHalf) bonusChance += (miracle.quality === '稀有') ? 0.15 : 0.10;
                            const chance = (0.0018 + accelStat * 0.0018) * (1 + bonusChance);
                            if (Math.random() < chance) {
                                const hasBurst = activeTypes.has('爆冲');
                                h.boostMult = (0.10 + 0.10 * accelStat) + (hasBurst ? 0.10 : 0);
                                h.boostTimer = Math.round(28 + 30 * accelStat + (hasBurst ? 20 : 0));
                                h.boostCooldown = Math.round(120 + 60 * (1 - accelStat));
                                const cost = 7 + (hasBurst ? 5 : 0);
                                h.staminaNow = Math.max(0, currStamina - cost);
                            }
                        }

                        const boostActive = (h.boostTimer || 0) > 0;
                        h.speed = boostActive ? (h.baseSpeedEff * (1 + (h.boostMult || 0))) : h.baseSpeedEff;

                        let drain = (0.035 + 0.00035 * h.speed);
                        if (boostActive) drain *= 1.35;
                        if (activeTypes.has('坚韧') && (Number(h.staminaNow) || 0) < 50) drain *= 0.75;
                        drain = drain / Math.max(0.35, enduranceEff);
                        let regen = 0;
                        if (activeTypes.has('回春')) regen += 0.012;
                        if (activeTypes.has('深息') && h.distance > 900) regen += 0.006;
                        if (activeTypes.has('坚韧') && (Number(h.staminaNow) || 0) < 40) regen += 0.004;
                        const nextStamina = Math.max(0, Math.min(staminaMax, (Number(h.staminaNow) || 0) - drain + regen));
                        h.staminaNow = nextStamina;
                    } else {
                        h.speed = h.baseSpeedEff;
                    }

                    if (!h.finished) {
                        h.distance += h.speed * 0.05;
                        if (h.distance >= finishDist) {
                            h.distance = finishDist;
                            h.finished = true;
                            h.finishPlace = (Number(this.finishCounter) || 0) + 1;
                            this.finishCounter = h.finishPlace;
                        }
                        const nextAt = Number(h.markNextAt) || 0;
                        if (nextAt > 0 && h.distance >= nextAt) {
                            const baseLeft = 50 + h.distance;
                            const markX = baseLeft + 32 + (Math.random() * 10 - 5);
                            const markY = (Number(h.baseTop) || 0) + 92 + (Math.random() * 6 - 3);
                            this.spawnTrackMark(h, markX, markY);
                            h.markNextAt = nextAt + 30 + Math.random() * 26;
                        }
                        h.el.style.setProperty('--race-x', Math.round(h.distance) + 'px');
                    }
                    if (h.finished) finishedCount++;

                    if (h.boostTimer && h.boostTimer > 0) {
                        h.boostTimer--;
                        if (enableGhostFx) h.afterimageTimer = Math.max(h.afterimageTimer || 0, 18);
                    }

                    const accelUp = h.speed > prevSpeed * 1.015;
                    if (accelUp) {
                        if (enableGhostFx) h.afterimageTimer = Math.max(h.afterimageTimer || 0, 22);
                    }
                    h._prevSpeed = h.speed;

                    if (h.burstCooldown && h.burstCooldown > 0) h.burstCooldown--;
                    const q = h.data && h.data.quality;
                    const isRarePlus = q === '稀有' || q === '史诗' || q === '神兽';
                    if (isRarePlus && !h.finished && h.distance < finishDist && h.burstCooldown <= 0 && (h.boostTimer > 0 || accelUp)) {
                        const intensity = 1 + (h.boostTimer ? Math.min(0.6, h.boostTimer / 100) : 0);
                        if (enableBurstFx) this.spawnBurst(h, intensity);
                        h.burstCooldown = 10;
                    }

                    if (h.afterimageTimer && h.afterimageTimer > 0) {
                        h.afterimageTimer--;
                        h.ghostCooldown = Math.max(0, (h.ghostCooldown || 0) - 1);
                        if (enableGhostFx && h.ghostCooldown <= 0 && !h.finished && h.distance < finishDist && (h.distance - prevDist) > 0) {
                            const intensity = Math.min(1.6, 0.8 + (h.afterimageTimer / 22));
                            this.spawnGhost(h, intensity);
                            h.ghostCooldown = 3;
                        }
                    } else {
                        h.ghostCooldown = Math.max(0, (h.ghostCooldown || 0) - 1);
                    }

                    // 赛中领悟逻辑：所有马匹都有机会
                    if (!h._learned && h.distance > 600) {
                        h._learned = true;
                        
                        // 玩家必触发，AI 30% 概率触发
                        const isPlayer = (h === playerHorse);
                        const shouldTrigger = isPlayer || (Math.random() < 0.3);

                        if (shouldTrigger) {
                             // 计算可领悟的非重复技能 OR 可升级的稀有技能
                            const existing = Array.isArray(h.data.genes) ? h.data.genes : [];
                            const allTypes = allowedGeneTypesForQuality(h.data && h.data.quality);
                            
                            // 动态概率：稀有度越高，领悟稀有技能概率越高
                            let rareProb = 0.1; // 默认普通马 10%
                            if (h.data.quality === '中级') rareProb = 0.15;
                            else if (h.data.quality === '高级') rareProb = 0.2;
                            else if (h.data.quality === '稀有') rareProb = 0.3;
                            else if (h.data.quality === '神兽') rareProb = 0.5;
                            
                            const isRare = Math.random() < rareProb; 
                            
                            // 候选列表 (全技能池)
                            const candidates = allTypes.filter(t => {
                                // 检查已拥有的最高等级 (包括当前携带 activeGenes 和仓库 data.genes)
                                const activeG = h.activeGenes.find(g => g.type === t);
                                const permG = (h.data.genes || []).find(g => g.type === t);
                                
                                const qMap = {'普通':0, '中级':1, '高级':2, '稀有':3, '史诗':4, '神兽':5};
                                const newQVal = qMap[isRare ? '稀有' : '普通'];
                                
                                let maxOwnedVal = -1;
                                if (activeG) maxOwnedVal = Math.max(maxOwnedVal, qMap[activeG.quality] || 0);
                                if (permG) maxOwnedVal = Math.max(maxOwnedVal, qMap[permG.quality] || 0);
                                
                                // 如果已拥有的等级 >= 新领悟的等级，则不再领悟
                                if (maxOwnedVal >= newQVal) return false;
                                
                                return true;
                            });

                            // 只要没学过，就能学
                            if (candidates.length > 0) {
                                let type = null;
                                let isUpgrade = false;
                                
                                type = candidates[Math.floor(Math.random() * candidates.length)];
                                const exist = h.activeGenes.find(g => g.type === type);
                                if (exist) isUpgrade = true;

                                if (type) {
                                    const quality = isRare ? '稀有' : '普通';
                                    const newGene = { type, quality };
                                    const slots = this.slotCountForHorse(h.data);
                                    if (isUpgrade) {
                                        const upgradeIdx = h.activeGenes.findIndex(g => g.type === type);
                                        if (upgradeIdx !== -1) h.activeGenes[upgradeIdx] = newGene;
                                        if (Array.isArray(h.data.lockedStartGenes)) {
                                            const lIdx = h.data.lockedStartGenes.findIndex(g => g.type === type);
                                            if (lIdx !== -1) h.data.lockedStartGenes[lIdx] = newGene;
                                        }
                                    } else {
                                        const limit = slots + 1; // 选中技能 + 1个新领悟
                                        const existsActive = h.activeGenes.some(g => g.type === type);
                                        if (!existsActive && h.activeGenes.length < limit) h.activeGenes.push(newGene);
                                    }
                                    
                                    // 同时也写入 data.genes (永久保存，满足收集需求)
                                    // 注意：这里需要再次检查 data.genes 里是否已有，因为 activeGenes 是子集
                                    if (!h.data.genes) h.data.genes = [];
                                    const permIdx = h.data.genes.findIndex(g => g.type === type);
                                    if (permIdx !== -1) {
                                        // 如果永久池里已有，看是否需要升级
                                        if (h.data.genes[permIdx].quality === '普通' && isRare) {
                                            h.data.genes[permIdx] = newGene;
                                        }
                                    } else {
                                        // 永久池里没有，直接添加
                                        h.data.genes.push(newGene);
                                    }
                                    // 同步当局激活列表到数据对象，供技能池高亮
                                    h.data.activeGenes = h.activeGenes;
                                    // 记录本局新领悟的技能，用于技能池红框高亮
                                    if (!h.data.learnedThisRace) h.data.learnedThisRace = [];
                                    if (!h.data.learnedThisRace.includes(type)) h.data.learnedThisRace.push(type);
                                    
                                    // 飘字效果
                                    const float = document.createElement('div');
                                    float.innerText = `💡 顿悟: ${type}${isRare?'(稀有)':''}!`;
                                float.style.position = 'absolute';
                                // 修正坐标计算
                                const cameraOffset = 150 - (50 + playerHorse.distance);
                                const nameLeft = (50 + h.distance) + cameraOffset;
                                const nameTop = 250 + h.baseTop + 20;

                                float.style.left = (nameLeft + 20) + 'px';
                                float.style.top = nameTop + 'px';
                                float.style.color = isRare ? '#e74c3c' : '#f1c40f'; // 稀有用红色
                                float.style.fontWeight = 'bold';
                                float.style.textShadow = '1px 1px 2px #000';
                                float.style.zIndex = '200';
                                float.style.whiteSpace = 'nowrap';
                                uiLayer.appendChild(float);
                                
                                // 动画上飘淡出
                            let op = 1, y = 0;
                            const anim = () => {
                                y += 1.5;
                                op -= 0.02;
                                float.style.transform = `translateY(-${y}px)`;
                                float.style.opacity = String(op);
                                    if (op > 0) requestAnimationFrame(anim);
                                    else if (float.parentNode) {
                                        float.parentNode.removeChild(float);
                                        if (window.game) window.game._pendingRaceUiRefresh = true;
                                    }
                            };
                            requestAnimationFrame(anim);
                                
                                // 刷新名牌
                                if (h.nameTag) {
                                    let geneHtml = '';
                                    if (h.activeGenes && h.activeGenes.length > 0) {
                                        geneHtml = h.activeGenes.map(g => 
                                            `<span class="mini-gene-tag" style="background:${g.quality==='普通'?'#bdc3c7':'#f1c40f'}; color:#000;">${g.type}</span>`
                                        ).join('');
                                    }
                                    if (h.data && h.data.id === this.selectedHorseId) h.nameTag.classList.add('is-player');
                                    else h.nameTag.classList.remove('is-player');
                                    h.nameTag.innerHTML = `<div class="name-row">${this.escapeHtml(this.truncateRaceName(h.data.name))}</div><div class="skill-row">${geneHtml}</div>`;
                                }
                                
                                // 领悟后稍微加速
                                h.speed *= 1.05;
                                h.boostTimer = 60;
                            }
                        }
                    }
                }

                });

                const leader = this.horses.reduce((prev, curr) => {
                    const prevKey = prev.finished ? (1000000 - (Number(prev.finishPlace) || 999999)) : (Number(prev.distance) || 0);
                    const currKey = curr.finished ? (1000000 - (Number(curr.finishPlace) || 999999)) : (Number(curr.distance) || 0);
                    return currKey > prevKey ? curr : prev;
                }, this.horses[0]);
                const cameraX = Math.max(0, Math.round(50 + (Number(leader.distance) || 0) - 200));
                const trackLayer = document.getElementById('track-layer');
                trackLayer.style.transform = `translate3d(${-cameraX}px,0,0)`;

                const trackContainer = document.getElementById('track-container');
                const trackContainerTop = trackContainer ? trackContainer.offsetTop : 0;
                const horseLeftBase = 50;
                const horseWidth = 120;
                this.horses.forEach(h => {
                    if (!h.nameTag) return;
                    const nameLeft = horseLeftBase + h.distance - cameraX + (horseWidth / 2);
                    const nameTop = trackContainerTop + h.baseTop;
                    h.nameTag.style.left = nameLeft + 'px';
                    h.nameTag.style.top = nameTop + 'px';
                    h.nameTag.style.transform = 'translate(-50%, -100%)';
                    if (h.data && h.data.id === this.selectedHorseId) h.nameTag.classList.add('is-player');
                    else h.nameTag.classList.remove('is-player');
                });

                // 镜头跟随逻辑 (已整合到上面循环中)
                // const targetX = 150 - playerHorse.distance;
                // const trackLayer = document.getElementById('track-layer');
                // trackLayer.style.transform = `translateX(${-playerHorse.distance}px)`;
                
                if (finishedCount >= this.horses.length) {
                    this.racing = false;
                    this.endRace();
                } else {
                    requestAnimationFrame(this.loop.bind(this));
                }
            }

            endRace() {
                // 1. 结算当前视觉组 (Player Group)
                this.horses.sort((a, b) => {
                    const ap = Number(a.finishPlace) || 999999;
                    const bp = Number(b.finishPlace) || 999999;
                    if (ap !== bp) return ap - bp;
                    const ad = Number(a.distance) || 0;
                    const bd = Number(b.distance) || 0;
                    return bd - ad;
                });
                const visualWinner = this.horses[0];
                const raceHorseId = this.currentRaceHorseId || this.selectedHorseId;
                const myHorseRankInGroup = this.horses.findIndex(h => h.data.id === raceHorseId) + 1;
                
                // 2. 模拟其他组的比赛结果
                // 我们不需要真的跑，只需要根据属性计算一个“模拟速度”并排序
                const allGroupResults = [];
                
                this.allGroups.forEach((group, gIdx) => {
                    let groupRankings = [];
                    if (gIdx === this.playerGroupIndex) {
                        // 玩家组使用实际跑完的结果
                        groupRankings = this.horses.map(h => h.data);
                    } else {
                        // 其他组模拟：计算速度并排序
                        // 简单模拟速度：baseSpeed + 技能加成
                        groupRankings = group.data.map(h => {
                            // 临时计算一个速度
                            const active = (h.lockedStartGenes||[]).slice(0, this.slotCountForHorse(h));
                            const speed = this.computeSpeedWithGenes(h.baseSpeed, active, h.genes, false);
                            return { horse: h, speed: speed };
                        }).sort((a,b) => b.speed - a.speed).map(o => o.horse);
                    }
                    allGroupResults.push({ name: group.name, rankings: groupRankings });
                });
                
                // 3. 记录数据和发放奖励 (仅基于玩家在自己组的排名)
                this.player.seasonRaces = (this.player.seasonRaces || 0) + 1;
                let reward = 0;
                // 奖励规则：1st=300, 2nd=250, 3rd=200, 4th=150, 5th=100, 6th=50
                const rewards = [300, 250, 200, 150, 100, 50];
                reward = rewards[myHorseRankInGroup - 1] || 10;
                
                this.player.integral += reward;
                
                if (myHorseRankInGroup === 1) {
                    this.player.seasonWins = (this.player.seasonWins || 0) + 1;
                    // 找到玩家马数据更新胜场
                    const myH = this.player.horses.find(h => h.id === raceHorseId);
                    if(myH) myH.wins = (myH.wins || 0) + 1;
                }
                
                if (myHorseRankInGroup >= 4) {
                    this.player.seasonBottoms = (this.player.seasonBottoms || 0) + 1;
                }
                
                const myHorse = this.player.horses.find(h => h.id === raceHorseId);
                if (myHorse) {
                    myHorse.totalRaces = (myHorse.totalRaces || 0) + 1;
                }

                this.promoteHorseToStableFront(raceHorseId);
                
                // 4. 构建结算面板信息 (显示所有组的前3名)
                let msg = `<div style="font-size:16px; color:#f1c40f; margin-bottom:10px;">${this.allGroups[this.playerGroupIndex].name} 排名: 第 ${myHorseRankInGroup} (奖励 ${reward})</div>`;
                
                msg += `<div style="display:flex; gap:10px; justify-content:center; text-align:left; font-size:10px;">`;
                allGroupResults.forEach(res => {
                    msg += `<div style="background:#34495e; padding:5px; border-radius:4px;">`;
                    msg += `<div style="color:#bdc3c7; border-bottom:1px solid #555; margin-bottom:3px;">${res.name}</div>`;
                    res.rankings.slice(0, 6).forEach((h, i) => {
                        const isMe = h.id === raceHorseId;
                        const color = isMe ? '#2ecc71' : (i===0 ? '#f1c40f' : '#ecf0f1');
                        msg += `<div style="color:${color};">${i+1}. ${h.name}</div>`;
                    });
                    msg += `</div>`;
                });
                msg += `</div>`;
                
                this.updateUI();
                this._pendingRaceUiRefresh = false;
                this.showResultPanel(msg); // 这里传入的是 HTML，需要修改 showResultPanel 支持 HTML
                this.currentRaceHorseId = null;

                // 移除所有跟随名牌
                this.horses.forEach(h => {
                    if (h.nameTag && h.nameTag.parentNode) {
                        h.nameTag.parentNode.removeChild(h.nameTag);
                    }
                });

                // 清空跑道内容，但不立刻返回大厅，交由结算面板处理返回逻辑
                document.getElementById('track-layer').innerHTML = '';
                document.getElementById('track-layer').style.transform = 'translateX(0)';
            }

            openDraft() {
                const races = this.player.seasonRaces || 0;
                const wins = this.player.seasonWins || 0;
                const bottoms = this.player.seasonBottoms || 0; // 倒数排名次数
                if (races < 8) {
                    alert("本赛季未结束（需完成 8 场比赛）才可进入选秀。");
                    return;
                }
                if (this.player && Array.isArray(this.player.horses) && this.player.horses.length >= this.stableCap) {
                    alert(`马厩已满 (${this.player.horses.length}/${this.stableCap})，请先清理一个马厩空位才能进行选秀。`);
                    return;
                }
                
                // 确定种子顺位 (1-14)
                if (!this.player.heldDraftPick || this.player.heldDraftPick.seasonNo !== this.player.seasonNo) {
                    // 基于倒数排名次数判定种子顺位
                    // 倒数次数 >= 6: 种子 1-3 (并列倒数第一，均等概率)
                    // 倒数次数 5: 种子 4
                    // ...
                    let seed = 14;
                    if (bottoms >= 6) seed = Math.floor(Math.random() * 3) + 1; // 1, 2, 3
                    else if (bottoms === 5) seed = 4;
                    else if (bottoms === 4) seed = 5;
                    else if (bottoms === 3) seed = 6;
                    else if (bottoms === 2) seed = 7;
                    else if (bottoms === 1) seed = Math.floor(Math.random() * 3) + 8; // 8-10
                    else seed = Math.floor(Math.random() * 4) + 11; // 11-14
                    
                    this.player.heldDraftPick = { 
                        seed: seed, 
                        isTraded: false,
                        originalOwner: '玩家',
                        seasonNo: this.player.seasonNo,
                        seasonStats: { races, wins, bottoms }
                    };
                }
                
                const seed = this.player.heldDraftPick.seed;
                const oddsMap = { 1: "14.0%", 2: "14.0%", 3: "14.0%", 4: "12.5%", 5: "10.5%", 6: "9.0%", 7: "7.5%", 8: "6.0%", 9: "4.5%", 10: "3.0%", 11: "2.0%", 12: "1.5%", 13: "1.0%", 14: "0.5%" };
                const odds = oddsMap[seed] || "0%";
                
                const statusHtml = `
                    <div class="draft-seed-line">
                        <div>本赛季战绩: ${wins}胜 / ${races}场 (倒数排名: ${bottoms}次)</div>
                        <div style="font-size:11px; color:#95a5a6;">状元概率: ${odds}</div>
                    </div>
                    <div class="draft-seed-line">
                        <div>乐透种子</div>
                        <div class="seed">#${seed}</div>
                    </div>
                `;
                document.getElementById('draft-status').innerHTML = statusHtml;
                document.getElementById('draft-result').style.display = 'none';
                document.getElementById('btn-start-draft').style.display = 'block';
                document.getElementById('btn-close-draft').style.display = 'none';
                document.getElementById('btn-open-trade').style.display = 'block';
                document.getElementById('draft-panel').style.display = 'flex';
                
                this.currentDraftSeed = seed;
                const seedEl = document.getElementById('draft-my-seed-val');
                const pickEl = document.getElementById('draft-final-pick-val');
                if (seedEl) seedEl.innerText = String(seed);
                if (pickEl) pickEl.innerText = '-';
                const selPrev = document.getElementById('draft-selected-preview');
                const selQual = document.getElementById('draft-selected-quality');
                const skillPool = document.getElementById('draft-skill-pool');
                if (selPrev) selPrev.innerHTML = '<div style="color:#95a5a6; font-size:12px;">未选择</div>';
                if (selQual) selQual.innerText = '未选择';
                if (skillPool) skillPool.innerHTML = '';
                const actions = document.getElementById('draft-actions');
                if (actions) actions.style.display = 'none';
                const codexBtn = document.getElementById('btn-draft-codex');
                if (codexBtn) codexBtn.style.display = 'none';
                this.stopDraftPreviewIdleAnim();
            }

            openTrade() {
                document.getElementById('draft-panel').style.display = 'none';
                document.getElementById('trade-panel').style.display = 'flex';
                this.updateTradeUI();
            }

            closeTrade() {
                document.getElementById('trade-panel').style.display = 'none';
                document.getElementById('draft-panel').style.display = 'flex';
                this.openDraft();
            }

            updateTradeUI() {
                document.getElementById('trade-my-points').innerText = this.player.integral;
                document.getElementById('trade-my-tier').innerText = `种子 ${this.player.heldDraftPick.seed}`;
                document.getElementById('trade-target-tier').innerText = '请选择';
                document.getElementById('trade-action-area').style.display = 'none';
                
                const list = document.getElementById('trade-list');
                list.innerHTML = '';
                
                // 生成 14 个 AI 对手 (对应种子 1-14)
                const aiTeams = [];
                for (let s = 1; s <= 14; s++) {
                    let name = `AI 队伍 ${s}`;
                    let desc = `种子 ${s}`;
                    if (s <= 3) {
                        name = `⚡ 摆烂大队 ${s}`;
                        desc = `状元热门 (14.0%)`;
                    } else if (s <= 6) {
                        name = `🛡️ 重建军团 ${s}`;
                        desc = `中游球队`;
                    } else if (s <= 10) {
                        name = `⚔️ 季后赛边缘 ${s}`;
                        desc = `冲击顺位`;
                    } else {
                        name = `🌪️ 夺冠热门 ${s}`;
                        desc = `强队 (0.5%状元)`;
                    }
                    
                    aiTeams.push({ name: name, seed: s, desc: desc });
                }
                
                aiTeams.forEach((ai, idx) => {
                    const item = document.createElement('div');
                    item.className = 'trade-team-item';
                    item.dataset.seed = String(ai.seed);
                    item.innerHTML = `
                        <div>
                            <div style="color:#ecf0f1; font-weight:bold;">${ai.name}</div>
                            <div style="font-size:10px; color:#7f8c8d;">${ai.desc}</div>
                        </div>
                        <div style="display:flex; flex-direction:column; align-items:flex-end; gap:4px;">
                            <div style="color:#f1c40f; font-weight:bold;">种子 ${ai.seed}</div>
                            <div class="trade-select-indicator">✓ 已选</div>
                        </div>
                    `;
                    item.onclick = () => this.selectTradeTarget(ai, item);
                    list.appendChild(item);
                });
            }

            selectTradeTarget(ai, el) {
                this.selectedTradeTarget = ai;
                const list = document.getElementById('trade-list');
                if (list) {
                    Array.from(list.children).forEach(node => node && node.classList && node.classList.remove('selected'));
                    if (el && el.classList) el.classList.add('selected');
                }
                document.getElementById('trade-target-tier').innerText = `种子 ${ai.seed}`;
                document.getElementById('trade-action-area').style.display = 'block';
                document.getElementById('trade-slider').value = 0;
                this.updateTradeCalc();
            }

            updateTradeCalc() {
                const addPoints = parseInt(document.getElementById('trade-slider').value);
                document.getElementById('trade-offer-val').innerText = addPoints;
                
                const mySeed = this.player.heldDraftPick.seed;
                const targetSeed = this.selectedTradeTarget.seed;
                
                // 价值估算: 种子越小越值钱
                // 种子1: 5000, 种子14: 100
                const getValue = (s) => Math.floor(5000 / Math.pow(1.2, s-1));
                const myVal = getValue(mySeed);
                const targetVal = getValue(targetSeed);
                
                const totalOffer = myVal + addPoints;
                const reqVal = targetVal * 1.1; 
                
                const msg = document.getElementById('trade-msg');
                if (totalOffer >= reqVal) {
                    msg.innerHTML = '<span style="color:#2ecc71">✅ 对方看起来很感兴趣</span>';
                    this.canTrade = true;
                } else {
                    const diff = reqVal - totalOffer;
                    msg.innerHTML = `<span style="color:#e74c3c">❌ 对方觉得筹码不够 (差约${Math.ceil(diff)})</span>`;
                    this.canTrade = false;
                }
            }

            executeTrade() {
                if (!this.canTrade) {
                    alert("对方拒绝了你的报价！请增加筹码。");
                    return;
                }
                const points = parseInt(document.getElementById('trade-slider').value);
                if (this.player.integral < points) {
                    alert("你的积分不足！");
                    return;
                }
                
                this.player.integral -= points;
                this.player.heldDraftPick.seed = this.selectedTradeTarget.seed;
                this.player.heldDraftPick.isTraded = true;
                
                alert(`交易成功！你获得了【${this.selectedTradeTarget.name}】的第 ${this.selectedTradeTarget.seed} 号种子！`);
                this.closeTrade();
            }

            startDraft() {
                // 模拟抽签动画
                const btn = document.getElementById('btn-start-draft');
                btn.style.display = 'none';
                // 抽签开始后，禁用/隐藏交易入口，防止作弊
                document.getElementById('btn-open-trade').style.display = 'none';
                
                const status = document.getElementById('draft-status');
                status.innerHTML = "🎲 正在进行乐透抽签...";
                
                setTimeout(() => {
                    this.performDraft();
                }, 1500);
            }

            performDraft() {
                const playerSeed = this.currentDraftSeed;
                const statusEl = document.getElementById('draft-status');
                
                statusEl.innerHTML = "🎲 正在进行乐透抽签...";

                const seedCombos = {
                    1: 140, 2: 140, 3: 140,
                    4: 125, 5: 105, 6: 90, 7: 75,
                    8: 60, 9: 45, 10: 30,
                    11: 20, 12: 15, 13: 10, 14: 5
                };

                const pool = [];
                for (let s = 1; s <= 14; s++) {
                    const n = seedCombos[s] || 0;
                    for (let i = 0; i < n; i++) pool.push(s);
                }

                const lotteryResults = [];
                for (let pick = 1; pick <= 4; pick++) {
                    const idx = Math.floor(Math.random() * pool.length);
                    const winner = pool[idx];
                    lotteryResults.push(winner);
                    for (let i = pool.length - 1; i >= 0; i--) {
                        if (pool[i] === winner) pool.splice(i, 1);
                    }
                }

                const rest = [];
                for (let s = 1; s <= 14; s++) {
                    if (!lotteryResults.includes(s)) rest.push(s);
                }
                const finalOrder = lotteryResults.concat(rest);
                
                // 找到玩家的最终顺位
                // finalOrder 的索引+1 即为顺位
                const playerPick = finalOrder.indexOf(playerSeed) + 1;
                
                this.currentPick = playerPick;
                
                setTimeout(() => {
                    const seedToPick = {};
                    finalOrder.forEach((s, idx) => { seedToPick[s] = idx + 1; });
                    const lotteryInfo = `
                        <div class="draft-pill-row">
                            ${finalOrder.map((s, idx) => `<div class="draft-pill ${idx < 4 ? 'is-top4' : ''}">${idx + 1}: 种子${s}</div>`).join('')}
                        </div>
                    `;
                    
                    document.getElementById('draft-pick-no').innerText = `第 ${playerPick}`;
                    statusEl.innerHTML = `${lotteryInfo}`;
                    const seedEl = document.getElementById('draft-my-seed-val');
                    const pickEl = document.getElementById('draft-final-pick-val');
                    if (seedEl) seedEl.innerText = String(playerSeed);
                    if (pickEl) pickEl.innerText = `第 ${playerPick} 顺位`;
                    
                    this.generateDraftPool();
                    document.getElementById('draft-result').style.display = 'block';
                    document.getElementById('btn-close-draft').style.display = 'none';
                    this.updateUI();
                }, 1000);
            }
            
            generateDraftPool() {
                const container = document.getElementById('draft-pool-container');
                container.innerHTML = '';
                this.draftPool = [];
                
                let hasMythical = false; // 标记是否已经生成过神兽
                const usedNames = new Set();
                (this.player.horses || []).forEach(h => { if (h && h.name) usedNames.add(String(h.name)); });
                (this.player.aiStable || []).forEach(h => { if (h && h.name) usedNames.add(String(h.name)); });

                // 生成 14 匹马作为候选 (对应14个乐透签)
                for (let i = 1; i <= 14; i++) {
                    // 只有顺位1有机会出神兽，前3出史诗，其他普通
                    // 这里的逻辑是：池子里什么马都有，但是能不能选到看顺位
                    
                    let quality = '普通';
                    
                    // 修正：确保只有一只神兽
                    if (i === 1) {
                         // 30% 概率出神兽
                        if (Math.random() < 0.3) {
                            quality = '神兽';
                            hasMythical = true;
                        } else {
                            quality = '稀有'; // 没出神兽，保底稀有（原逻辑是史诗或稀有，这里简化）
                        }
                    } 
                    // 兜底：如果前面没出神兽，后面也不允许出了
                    else if (i <= 3) quality = Math.random() < 0.5 ? '史诗' : '稀有';
                    else if (i <= 6) quality = Math.random() < 0.4 ? '高级' : '中级';
                    else quality = '普通';
                    
                    const name = this.pickUniqueNewYearName(usedNames);
                    // 生成马匹数据
                    const horse = {
                        id: 'pool_' + i,
                        name: name,
                        color: quality==='神兽'?'#e74c3c':(quality==='史诗'?'#9b59b6':(quality==='稀有'?'#f1c40f':'#ecf0f1')),
                        quality: quality,
                        data: this.createDraftHorseData(quality, name),
                        rating: 'C'
                    };
                    const genes = horse.data && Array.isArray(horse.data.genes) ? horse.data.genes : [];
                    const totalSkills = genes.length;
                    const rareSkills = genes.filter(g => g && g.quality === '稀有').length;
                    const isRareOrAbove = (quality === '稀有' || quality === '史诗' || quality === '神兽');
                    if (isRareOrAbove) {
                        horse.rating = (rareSkills >= 2)
                            ? 'S'
                            : (rareSkills === 1)
                                ? 'A'
                                : (totalSkills >= 9 ? 'B' : 'C');
                    } else {
                        horse.rating = (rareSkills >= 3)
                            ? 'S'
                            : (rareSkills === 2)
                                ? 'A'
                                : (totalSkills >= 9 ? 'B' : 'C');
                    }
                    this.draftPool.push(horse);
                }
                
                // 如果当前是玩家顺位(currentPick)，前面的马已经被AI选走了
                // 简单模拟：如果玩家是第3顺位，那么池子里最好的2匹马已经被移除了
                // 我们直接移除前 (pick-1) 个高质量的马
                // 先按真实质量排序
                const sortedPool = [...this.draftPool].sort((a,b) => {
                    const qMap = {'神兽':5, '稀有':4, '史诗':3, '高级':2, '中级':1, '普通':0};
                    return qMap[b.quality] - qMap[a.quality];
                });
                
                // 玩家顺位
                const playerPick = this.currentPick || parseInt(document.getElementById('draft-pick-no').innerText) || 14;

                // AI 选走前 (currentPick - 1) 个
                const available = sortedPool.slice(playerPick - 1);
                
                // 模拟：被 AI 选走的马，真正加入 AI 马厩
                const aiPicked = sortedPool.slice(0, playerPick - 1);
                aiPicked.forEach(h => {
                    // AI 得到这匹马
                    if (!this.player.aiStable) this.player.aiStable = [];
                    this.player.aiStable.push(h.data);
                });

                // 确保 AI 马厩里的神兽数量也受到限制
                // 遍历 aiStable，如果有超过1只神兽，把多余的降级为史诗或稀有
                if (this.player.aiStable) {
                    const mythicals = this.player.aiStable.filter(h => h.quality === '神兽');
                    if (mythicals.length > 1) {
                        // 保留最新的一只，其他的降级
                        // 从第二个开始降级
                        for (let i = 1; i < mythicals.length; i++) {
                            mythicals[i].quality = '史诗';
                            mythicals[i].color = '#9b59b6';
                            mythicals[i].name = mythicals[i].name.replace('神兽', '史诗'); // 改名
                        }
                    }
                }

                // 打乱顺序显示，不让玩家直接看出哪个最好（虽然评级能看出来）
                const displayList = available.sort(() => 0.5 - Math.random());
                
                displayList.forEach(h => {
                    const div = document.createElement('div');
                    div.className = 'draft-card';
                    div.style.cssText = `
                        width: 90px; height: 110px;
                        background-image: linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.5)), url('assets/icon.png');
                        background-position: center;
                        background-size: cover;
                        background-repeat: no-repeat;
                        border: 1px solid #555;
                        border-radius: 6px; display: flex; flex-direction: column;
                        align-items: center; justify-content: flex-start; cursor: pointer;
                        transition: transform 0.1s;
                        padding-top: 10px;
                    `;
                    const spMin = (h.data && typeof h.data.speedRangeMin === 'number') ? h.data.speedRangeMin : '';
                    const spMax = (h.data && typeof h.data.speedRangeMax === 'number') ? h.data.speedRangeMax : '';
                    const skillCount = (h.data && Array.isArray(h.data.genes)) ? h.data.genes.length : 0;
                    div.innerHTML = `
                        <div style="font-size:12px; margin-top:28px; color:#f1c40f; font-weight:800; text-shadow:0 1px 2px rgba(0,0,0,0.9), 0 0 6px rgba(241,196,15,0.35);">${h.name}</div>
                        <div style="font-size:14px; color:#f1c40f; font-weight:bold;">${h.rating}</div>
                        <div style="font-size:10px; color:#ecf0f1; text-shadow:0 1px 2px rgba(0,0,0,0.9);">速度: ${spMin}-${spMax}</div>
                        <div style="font-size:10px; color:#ecf0f1; text-shadow:0 1px 2px rgba(0,0,0,0.9);">技能池数量: ${skillCount}</div>
                    `;
                    div.onclick = () => this.selectDraftHorse(h, div);
                    container.appendChild(div);
                });
            }
            
            getRatingByRank(rank, realQuality) {
                // 基于排名区间的评级逻辑
                // 1-5名: 显示 S
                // 6-10名: 显示 A
                // 11-15名: 显示 B (实际上我们只生成10个，所以是 6-10=A)
                // 但这里我们只有10个池子，所以调整一下：
                // 1-3: S
                // 4-7: A
                // 8-10: B
                
                let rating = 'B';
                if (rank <= 3) rating = 'S';
                else if (rank <= 7) rating = 'A';
                
                // 增加迷惑性：有概率显示不准
                // 比如把 S 显示成 A (被低估)，或者 B 显示成 A (被高估)
                const rnd = Math.random();
                if (rnd < 0.2) {
                    if (rating === 'S') rating = 'A';
                    else if (rating === 'A') rating = Math.random()<0.5 ? 'S' : 'B';
                    else if (rating === 'B') rating = 'A';
                }
                
                return rating;
            }
            
            getRatingByQuality(q) {
                // 废弃，改用 getRatingByRank
                return 'C';
            }
            
            createDraftHorseData(quality, nameOverride) {
                 // 修复：确保 ID 唯一性，避免多只神兽马因随机数碰撞或逻辑复制导致 ID 相同
                 // 虽然 Date.now() 很快，但循环中可能相同，加个大的随机数
                 const id = 'draft_' + Date.now() + '_' + Math.floor(Math.random() * 1000000);
                 const lifespan = quality==='神兽'?80 : (quality==='史诗'?70 : 60);
                 const horse = {
                    id: id,
                    name: String(nameOverride || (quality + '新秀')),
                    color: quality==='神兽'?'#e74c3c':(quality==='史诗'?'#9b59b6':(quality==='稀有'?'#f1c40f':'#ecf0f1')),
                    quality: quality,
                    baseSpeed: rollInt(getQualityStats(quality).baseSpeedMin, getQualityStats(quality).baseSpeedMax),
                    stamina: getQualityStats(quality).stamina,
                    endurance: getQualityStats(quality).endurance,
                    accel: getQualityStats(quality).accel,
                    temper: 0.5,
                    lifespan: lifespan,
                    maxLifespan: lifespan,
                    genes: [],
                    geneSlots: Math.max(5, this.slotCountForHorse({quality})), // 选秀马至少5个槽
                    totalRaces: 0,
                    lockedStartGenes: [],
                    spriteSet: quality === '神兽'
                        ? pickLegendarySpriteSet()
                        : (quality === '史诗'
                            ? SpriteSet.Epic
                            : (quality === '稀有'
                                ? (Math.random() < 0.5 ? SpriteSet.Rare : SpriteSet.Rare2)
                                : (Math.random() < 0.35 ? SpriteSet.Base : SpriteSet.Horse)))
                };
                const allTypes = allowedGeneTypesForQuality(quality);
                const totalCount = 5 + Math.floor(Math.random() * 6);
                const isRareOrAbove = (quality === '稀有' || quality === '史诗' || quality === '神兽');
                const minRare = isRareOrAbove ? 1 : 0;
                const maxRare = Math.min(3, totalCount);
                const rareCount = minRare + Math.floor(Math.random() * (maxRare - minRare + 1));
                const picked = [...allTypes].sort(() => 0.5 - Math.random()).slice(0, Math.min(totalCount, allTypes.length));
                if (quality === '神兽' && !picked.includes('天命')) {
                    const idx = Math.floor(Math.random() * picked.length);
                    picked[idx] = '天命';
                }
                if (quality === '史诗' && !picked.includes('传说')) {
                    const idx = Math.floor(Math.random() * picked.length);
                    picked[idx] = '传说';
                }
                const uniq = new Map();
                picked.forEach(t => { if (!uniq.has(t)) uniq.set(t, t); });
                const pickedUniq = Array.from(uniq.values());
                while (pickedUniq.length < Math.min(totalCount, allTypes.length)) {
                    const t = allTypes[Math.floor(Math.random() * allTypes.length)];
                    if (!pickedUniq.includes(t)) pickedUniq.push(t);
                }
                const genes = pickedUniq.slice(0, Math.min(totalCount, allTypes.length)).map(t => ({ type: t, quality: '普通' }));
                if (rareCount > 0) {
                    const idxs = Array.from({length: genes.length}, (_, i) => i).sort(() => 0.5 - Math.random()).slice(0, rareCount);
                    idxs.forEach(i => { if (genes[i]) genes[i].quality = '稀有'; });
                }
                horse.genes = genes;
                this.ensureLockedStartGenes(horse);
                const speedSlots = this.slotCountForHorse(horse);
                const active = (horse.lockedStartGenes || []).slice(0, speedSlots);
                const allAttrBoost = this.computeAllAttrBoostPct(horse, active);
                const actual = Math.round(this.computeSpeedWithGenes((Number(horse.baseSpeed) || 0) * (1 + allAttrBoost), active, horse.genes, false));
                const down = 3 + Math.floor(Math.random() * 3);
                const up = 3 + Math.floor(Math.random() * 3);
                horse.speedRangeMin = Math.max(1, actual - down);
                horse.speedRangeMax = Math.max(horse.speedRangeMin + 1, actual + up);
                return horse;
            }
            
            selectDraftHorse(horseObj, el) {
                if (this.hasDrafted) return;
                if (this.player && Array.isArray(this.player.horses) && this.player.horses.length >= this.stableCap) {
                    alert(`马厩已满 (${this.player.horses.length}/${this.stableCap})，请先退役一匹马再完成选秀。`);
                    return;
                }
                
                // 选中视觉反馈
                const cards = document.querySelectorAll('.draft-card');
                cards.forEach(c => c.style.border = '1px solid #555');
                el.style.border = '2px solid #2ecc71';
                const selPrev = document.getElementById('draft-selected-preview');
                const selQual = document.getElementById('draft-selected-quality');
                const skillPool = document.getElementById('draft-skill-pool');
                if (selPrev) {
                    const spriteSet = (horseObj && horseObj.data && horseObj.data.spriteSet) ? horseObj.data.spriteSet : SpriteSet.Horse;
                    selPrev.innerHTML = `<div class="idle-horse" data-sprite-set="${this.escapeHtml(spriteSet)}" data-idle-horse="1"></div>`;
                    const idleEl = selPrev.querySelector('.idle-horse');
                    if (idleEl) idleEl.style.backgroundImage = this.horseRunFrame(1, spriteSet);
                    this.startDraftPreviewIdleAnim(spriteSet);
                }
                if (selQual) selQual.innerText = this.escapeHtml(horseObj.quality || '普通');
                if (skillPool) {
                    const genes = (horseObj && horseObj.data && Array.isArray(horseObj.data.genes)) ? horseObj.data.genes : [];
                    skillPool.innerHTML = genes.map(g => {
                        const q = (g && g.quality) ? g.quality : '普通';
                        const cls = q === '稀有' || q === '神兽' || q === '史诗' ? 'gene-rare' : 'gene-normal';
                        return `<div class="gene-tag ${cls}" title="${this.escapeHtml(q)}">${this.escapeHtml(g && g.type ? g.type : '')}</div>`;
                    }).join('');
                }
                
                if (confirm(`确定选择评级为【${horseObj.rating}】的马匹吗？\n(技能将在入队后揭晓)`)) {
                    this.hasDrafted = true;
                    
                    // 深度克隆：防止引用同一对象导致数据互通
                    // 选秀池里的 horseObj.data 是原始对象，如果不克隆，
                    // 可能会出现 AI 马厩和玩家马厩引用同一个对象的情况（如果逻辑有漏洞）
                    // 尤其是当洗练修改属性时，必须确保是独立对象
                    const newHorse = JSON.parse(JSON.stringify(horseObj.data));
                    
                    // 再次确保 ID 唯一：虽然 createDraftHorseData 已经随机了，但入队时再刷新一次最稳妥
                    newHorse.id = 'h_' + Date.now() + '_' + Math.floor(Math.random() * 10000);
                    
                    this.draftedHorse = newHorse;
                    
                    // 加入马厩
                    this.player.horses.push(newHorse);
                    
                    // 自动选中新马
                    this.selectedHorseId = newHorse.id;
                    const pageSize = this.stablePageSize || 4;
                    const idx = this.player.horses.findIndex(h => h && h.id === newHorse.id);
                    if (idx >= 0) this.stablePage = Math.floor(idx / pageSize);
                    this.pushHint(`🎉 签约新马：${newHorse.name}`);
                    this.updateUI();
                    
                    // 显示结果
                    document.getElementById('draft-pool-container').innerHTML = '';
                    
                    // 显示下一步按钮
                    document.getElementById('btn-close-draft').style.display = 'flex';
                    document.getElementById('btn-trade-new-horse').style.display = 'flex';
                    document.getElementById('btn-market-trade').style.display = 'flex';
                    document.getElementById('btn-draft-codex').style.display = 'flex';
                    const actions = document.getElementById('draft-actions');
                    if (actions) actions.style.display = 'grid';
                    
                    // 将剩余的选秀马匹加入 AI 马厩，使其可交易
                    this.draftPool.forEach(poolHorse => {
                        // 跳过玩家选中的马（通过原始ID判断，或者直接根据引用）
                        // 注意：这里 poolHorse.data 还是原始对象，而我们刚才克隆了 newHorse
                        // 所以要对比 poolHorse.data.id 和 horseObj.data.id
                        if (poolHorse.data.id === horseObj.data.id) return;
                        
                        // 同样深度克隆 AI 的马，防止任何潜在引用关联
                        const aiHorse = JSON.parse(JSON.stringify(poolHorse.data));
                        
                        // 确保 AI 马匹有名字 (去掉 "新秀-" 前缀，或者随机个名字)
                        // ... (原有 AI 命名逻辑)
                        // 确保 AI 马厩里的神兽数量也受到限制
                        // ...
                        
                        // 这里需要把之前的 AI 入队逻辑搬过来，并应用到 clone 的对象上
                         if (!this.player.aiStable) this.player.aiStable = [];
                         
                        const nowAiId = () => 'ai_' + Date.now() + '_' + Math.floor(Math.random() * 100000);
                        const aiUsed = new Set((this.player.aiStable || []).map(h => h && h.id).filter(Boolean));
                        aiHorse.id = aiHorse.id || nowAiId();
                        while (aiUsed.has(aiHorse.id)) aiHorse.id = nowAiId();

                        if (aiHorse.quality === '神兽') {
                             const suffixes = ['天命', '传奇', '无双', '至尊', '幻影', '霸主', '星辰'];
                             const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
                             aiHorse.name = "AI-神兽·" + suffix;
                         } else {
                             aiHorse.name = 'AI-' + aiHorse.name;
                         }
                         
                         // 赋予随机技能 (模拟 AI 领悟)
                        if (!aiHorse.genes || aiHorse.genes.length === 0) {
                            const slots = this.slotCountForHorse(aiHorse);
                            const baseTypes = allowedGeneTypesForQuality(aiHorse.quality);
                            const pool = baseTypes.map(t => ({type:t, quality:'普通'}));
                            aiHorse.genes = this.pickStartGenes(pool, Math.floor(Math.random() * slots));
                        }
                         
                         this.player.aiStable.push(aiHorse);
                    });
                    
                    // AI 马厩神兽去重逻辑 (同上)
                    if (this.player.aiStable) {
                        const mythicals = this.player.aiStable.filter(h => h.quality === '神兽');
                        if (mythicals.length > 1) {
                            for (let i = 1; i < mythicals.length; i++) {
                                mythicals[i].quality = '史诗';
                                mythicals[i].color = '#9b59b6';
                                mythicals[i].name = mythicals[i].name.replace('神兽', '史诗');
                            }
                        }
                    }
                    
                    // 简单的 AI 马厩清理 (保留最新的 30 匹，避免无限膨胀)
                    if (this.player.aiStable.length > 30) {
                        // 按价值排序，保留价值高的
                        this.player.aiStable.sort((a,b) => this.calculateHorseValue(b) - this.calculateHorseValue(a));
                        this.player.aiStable = this.player.aiStable.slice(0, 30);
                    }
                    
                    if (this.player.horses.length > this.stableCap) {
                        alert("马厩爆满！请尽快清理旧马。");
                    }
                }
            }
            
            openHorseTrade() {
                if (!this.draftedHorse) return;
                
                // 计算交易价格：基于资质动态定价
                const quality = this.draftedHorse.quality;
                // 神兽=4000, 稀有=3000, 史诗=2500, 高级=2000, 中级=1500, 普通=1000
                const priceMap = {'神兽':4000, '稀有':3000, '史诗':2500, '高级':2000, '中级':1500, '普通':1000};
                this.currentTradePrice = priceMap[quality] || 1000;
                
                document.getElementById('horse-trade-price').innerText = this.currentTradePrice + '积分';
                document.getElementById('horse-trade-modal').style.display = 'flex';
            }
            
            cancelHorseTrade() {
                document.getElementById('horse-trade-modal').style.display = 'none';
            }
            
            confirmHorseTrade() {
                // 卖掉刚选的马
                const idx = this.player.horses.findIndex(h => h.id === this.draftedHorse.id);
                if (idx !== -1) {
                    this.player.horses.splice(idx, 1);
                    this.player.integral += this.currentTradePrice;
                    alert(`交易成功！获得 ${this.currentTradePrice} 积分。`);
                }
                this.cancelHorseTrade();
                this.closeDraft();
            }

            closeDraft() {
                this.hasDrafted = false;
                this.draftedHorse = null;
                this.stopDraftPreviewIdleAnim();
                document.getElementById('draft-panel').style.display = 'none';
                document.getElementById('btn-trade-new-horse').style.display = 'none'; // 隐藏按钮
                document.getElementById('btn-market-trade').style.display = 'none'; // 隐藏按钮
                
                // --- 新增：奖杯结算逻辑 ---
                // 赛季结算：按总胜率判断，模拟和其他AI对比
                // 假设：如果胜率 >= 40% 且 场次 >= 8，算作赛季第一（简化逻辑）
                const races = this.player.seasonRaces || 0;
                const wins = this.player.seasonWins || 0;
                const rate = races > 0 ? (wins / races) * 100 : 0;
                
                // 重置荣誉状态
                this.player.hasSeasonChampion = false;

                if (races >= 8 && rate >= 40) {
                    this.player.trophies = (this.player.trophies || 0) + 1;
                    this.player.hasSeasonChampion = true; // 获得下赛季的荣誉显示
                    
                    // 检查是否合并高级奖杯
                    const total = this.player.trophies;
                    if (total % 10 === 0) {
                        alert(`🏆 恭喜！你获得了第 ${total} 个奖杯，已自动合成高级荣誉！\n(本赛季胜率: ${rate.toFixed(1)}%)`);
                    } else {
                        alert(`🏆 赛季结算：恭喜获得赛季第一！\n奖杯 +1 (当前: ${total})\n(本赛季胜率: ${rate.toFixed(1)}%)`);
                    }
                } else if (races >= 8) {
                    alert(`赛季结束。\n胜率: ${rate.toFixed(1)}% (未达到冠军标准 40%)\n继续加油！`);
                }
                // -------------------------

                // 重置赛季
                this.player.seasonRaces = 0;
                this.player.seasonWins = 0;
                this.player.seasonBottoms = 0;
                // 重置选秀权，确保新赛季重新根据胜率计算
                this.player.heldDraftPick = null;
                this.player.seasonNo = (this.player.seasonNo || 1) + 1;
                
                this.updateUI();
                alert("新赛季已开启！");
            }
            
            // --- 球员交易市场逻辑 ---
            openMarket() {
                document.getElementById('market-panel').style.display = 'flex';
                this.selectedMarketTarget = null;
                this.selectedMarketChips = new Set();
                this.selectedMarketChipFocus = null;
                this.renderMarket();
                this.updateMarketCalc();
            }
            
            closeMarket() {
                document.getElementById('market-panel').style.display = 'none';
            }
            
            renderMarket() {
                // 1. 渲染 AI 马列表 (只显示 player.aiStable 里的)
                const aiList = document.getElementById('market-ai-list');
                aiList.innerHTML = '';
                const aiStable = this.player.aiStable || [];
                
                if (aiStable.length === 0) {
                    aiList.innerHTML = '<div style="color:#7f8c8d; padding:10px;">AI 暂无可交易马匹</div>';
                } else {
                    aiStable.forEach(h => {
                        const val = this.calculateHorseValue(h);
                        const card = document.createElement('div');
                        card.style.cssText = `min-width:100px; background:#2c3e50; border:1px solid #7f8c8d; border-radius:6px; padding:5px; text-align:center; cursor:pointer; position:relative;`;
                        card.innerHTML = `
                            <div style="font-size:12px; font-weight:bold; color:${h.quality==='神兽'?'#e74c3c':(h.quality==='史诗'?'#9b59b6':(h.quality==='稀有'?'#f1c40f':'#ecf0f1'))}">${h.name}</div>
                            <div style="font-size:10px; color:#bdc3c7;">${h.quality}</div>
                            <div style="font-size:10px; color:#f1c40f;">评分: ${val}</div>
                        `;
                        card.onclick = () => {
                            // 单选
                            this.selectedMarketTarget = h;
                            Array.from(aiList.children).forEach(c => c.style.border = '1px solid #7f8c8d');
                            card.style.border = '2px solid #e74c3c';
                            this.updateMarketCalc();
                        };
                        aiList.appendChild(card);
                    });
                }
                
                // 2. 渲染我的筹码 (显示所有马匹，包括刚选的)
                const myList = document.getElementById('market-my-list');
                myList.innerHTML = '';
                this.player.horses.forEach(h => {
                    const val = this.calculateHorseValue(h);
                    const card = document.createElement('div');
                    card.style.cssText = `min-width:100px; background:#2c3e50; border:1px solid #7f8c8d; border-radius:6px; padding:5px; text-align:center; cursor:pointer;`;
                    card.innerHTML = `
                        <div style="font-size:12px; font-weight:bold; color:${h.color}">${h.name}</div>
                        <div style="font-size:10px; color:#bdc3c7;">${h.quality}</div>
                        <div style="font-size:10px; color:#2ecc71;">评分: ${val}</div>
                    `;
                    card.onclick = () => {
                        // 多选
                        if (this.selectedMarketChips.has(h)) {
                            this.selectedMarketChips.delete(h);
                            card.style.border = '1px solid #7f8c8d';
                            if (this.selectedMarketChipFocus === h) {
                                this.selectedMarketChipFocus = Array.from(this.selectedMarketChips)[0] || null;
                            }
                        } else {
                            if (this.selectedMarketChips.size >= 3) {
                                const msg = document.getElementById('market-msg');
                                if (msg) msg.innerHTML = '<span style="color:#e74c3c">最多只能选择 3 匹筹码马</span>';
                                return;
                            }
                            this.selectedMarketChips.add(h);
                            card.style.border = '2px solid #2ecc71';
                            this.selectedMarketChipFocus = h;
                        }
                        this.updateMarketCalc();
                    };
                    myList.appendChild(card);
                });
            }
            
            calculateHorseValue(h) {
                // 简单的价值评估公式
                const qMap = {'神兽':5000, '史诗':3000, '稀有':2000, '高级':1200, '中级':800, '普通':500};
                let val = qMap[h.quality] || 500;
                
                // 速度加成
                val += Math.floor((h.baseSpeed - 55) * 50);
                
                // 技能加成 (永久技能)
                if (h.genes) {
                    h.genes.forEach(g => {
                        if (g.quality === '神兽') val += 800;
                        else if (g.quality === '史诗') val += 500;
                        else if (g.quality === '稀有') val += 300;
                        else val += 50;
                    });
                }
                return Math.floor(val);
            }
            
            updateMarketCalc() {
                const targetVal = this.selectedMarketTarget ? this.calculateHorseValue(this.selectedMarketTarget) : 0;
                document.getElementById('market-target-val').innerText = targetVal;

                const targetPreview = document.getElementById('market-target-preview');
                if (targetPreview) {
                    if (this.selectedMarketTarget) {
                        const spriteSet = this.selectedMarketTarget.spriteSet || SpriteSet.Horse;
                        const q = this.selectedMarketTarget.quality;
                        const nameColor = q==='神兽'?'#e74c3c':(q==='史诗'?'#9b59b6':(q==='稀有'?'#f1c40f':'#ecf0f1'));
                        targetPreview.innerHTML = `
                            <div class="market-side-preview">
                                <div class="idle-horse market-idle-horse" data-sprite-set="${this.escapeHtml(spriteSet)}" data-idle-horse="1"></div>
                                <div class="market-side-name" style="color:${nameColor}">${this.escapeHtml(this.selectedMarketTarget.name)}</div>
                                <div class="market-side-sub">${this.escapeHtml(q)}</div>
                            </div>
                        `;
                    } else {
                        targetPreview.innerHTML = '<div style="color:#95a5a6; font-size:12px;">未选择目标马</div>';
                    }
                }

                const myPreview = document.getElementById('market-my-preview');
                if (myPreview) {
                    const chips = Array.from(this.selectedMarketChips || []);
                    if (chips.length > 0) {
                        const maxShow = 3;
                        const show = chips.slice(0, maxShow);
                        const more = chips.length - show.length;
                        const namesHtml = show.map(h => {
                            const name = h && h.name ? String(h.name) : '';
                            const color = h && h.color ? String(h.color) : '#ecf0f1';
                            return `<div class="market-chip-name" style="color:${this.escapeHtml(color)}">${this.escapeHtml(name)}</div>`;
                        }).join('');
                        const horsesHtml = show.map(h => {
                            const spriteSet = (h && h.spriteSet) ? h.spriteSet : SpriteSet.Horse;
                            return `<div class="idle-horse" data-sprite-set="${this.escapeHtml(spriteSet)}" data-idle-horse="1"></div>`;
                        }).join('');
                        myPreview.innerHTML = `
                            <div class="market-side-preview">
                                <div class="market-chip-preview">
                                    ${horsesHtml}
                                    ${more > 0 ? `<div class="market-chip-more">+${more}</div>` : ``}
                                </div>
                                <div class="market-chip-names">${namesHtml}</div>
                                <div class="market-side-sub">已选筹码：${chips.length}匹</div>
                            </div>
                        `;
                    } else {
                        myPreview.innerHTML = '<div style="color:#95a5a6; font-size:12px;">未选择筹码马</div>';
                    }
                }
                const marketPanel = document.getElementById('market-panel');
                if (marketPanel) this.startStableIdleAnim(marketPanel);
                
                let myVal = 0;
                this.selectedMarketChips.forEach(h => {
                    myVal += this.calculateHorseValue(h);
                });
                
                const points = parseInt(document.getElementById('market-points-slider').value);
                // 积分折算价值：1积分 = 1价值 (或者打折)
                myVal += points;
                
                document.getElementById('market-my-val').innerText = myVal;
                document.getElementById('market-points-val').innerText = points;
                
                const msg = document.getElementById('market-msg');
                
                if (!this.selectedMarketTarget) {
                    msg.innerHTML = '<span style="color:#bdc3c7">请选择目标马匹</span>';
                    return;
                }
                
                // 交易门槛：需要溢价 10%
                const reqVal = Math.floor(targetVal * 1.1);
                
                if (myVal >= reqVal) {
                    msg.innerHTML = '<span style="color:#2ecc71">✅ 交易可行</span>';
                } else {
                    msg.innerHTML = `<span style="color:#e74c3c">❌ 筹码不足 (差值: ${reqVal - myVal})</span>`;
                }
            }
            
            executeMarketTrade() {
                if (!this.selectedMarketTarget) {
                    alert("请先选择要交易的目标马匹！");
                    return;
                }
                
                const targetVal = this.calculateHorseValue(this.selectedMarketTarget);
                let myVal = 0;
                this.selectedMarketChips.forEach(h => myVal += this.calculateHorseValue(h));
                const points = parseInt(document.getElementById('market-points-slider').value);
                myVal += points;
                
                const reqVal = Math.floor(targetVal * 1.1);
                
                if (myVal < reqVal) {
                    alert(`对方认为您的筹码不足！\n目标价值(含溢价): ${reqVal}\n当前价值: ${myVal}`);
                    return;
                }
                
                if (this.player.integral < points) {
                    alert("您的积分不足！");
                    return;
                }
                
                // 检查马厩容量
                // 逻辑：失去 N 匹，得到 1 匹。容量变化 = 1 - N
                // 如果 N=0 (纯积分买)，则容量+1，需检查上限
                const chipsCount = this.selectedMarketChips.size;
                const newCount = this.player.horses.length - chipsCount + 1;
                
                // 这里允许暂时超上限？或者严格限制
                if (newCount > this.stableCap) {
                    alert(`交易后马厩将超员 (${newCount}/${this.stableCap})！请增加筹码马匹数量。`);
                    return;
                }
                
                if (confirm(`确定执行交易吗？\n将失去: ${chipsCount}匹马 + ${points}积分\n获得: ${this.selectedMarketTarget.name}`)) {
                    // 扣除积分
                    this.player.integral -= points;
                    
                    // 移除筹码马匹
                    this.selectedMarketChips.forEach(chip => {
                        const idx = this.player.horses.indexOf(chip);
                        if (idx !== -1) this.player.horses.splice(idx, 1);
                    });
                    
                    // 获得目标马匹
                    const target = this.selectedMarketTarget;
                    // 从 AI 马厩移除
                    const aiIdx = this.player.aiStable.indexOf(target);
                    if (aiIdx !== -1) this.player.aiStable.splice(aiIdx, 1);
                    
                    const acquired = JSON.parse(JSON.stringify(target || {}));
                    const nowId = () => 'h_' + Date.now() + '_' + Math.floor(Math.random() * 100000);
                    const used = new Set((this.player.horses || []).map(h => h && h.id).filter(Boolean));
                    acquired.id = acquired.id || nowId();
                    while (used.has(acquired.id)) acquired.id = nowId();
                    if (typeof acquired.name === 'string' && acquired.name.startsWith('AI-')) acquired.name = acquired.name.replace('AI-', '');
                    this.player.horses.push(acquired);
                    this.selectedHorseId = acquired.id;
                    
                    // 筹码马匹给 AI (可选，这里直接移除也就是退役/流放)
                    
                    alert("交易成功！");
                    this.closeMarket();
                    this.updateUI();
                    
                    // 刷新 Draft 界面按钮状态 (如果卖掉了 draftedHorse，按钮要处理吗？)
                    // 如果把 draftedHorse 卖了，draftedHorse 变量还在引用它吗？
                    // 最好重置 draftedHorse
                    if (this.selectedMarketChips.has(this.draftedHorse)) {
                        this.draftedHorse = null;
                        document.getElementById('btn-trade-new-horse').style.display = 'none';
                    }
                }
            }
        }

        window.game = new Game();
        
        // 结算面板逻辑
        Game.prototype.showResultPanel = function(text) {
            const panel = document.getElementById('result-panel');
            const titleEl = document.getElementById('result-title');
            const descEl = document.getElementById('result-desc');
            const cdEl = document.getElementById('result-countdown');
            const btnBack = document.getElementById('btn-back-lobby');
            
            titleEl.innerText = "比赛结算";
            descEl.innerHTML = text; // 允许 HTML
            panel.style.display = 'flex';
            
            let left = 5; // 延长到5秒
            cdEl.innerText = `自动返回 (${left}s)`;
            
            let timer = setInterval(() => {
                left--;
                cdEl.innerText = `自动返回 (${left}s)`;
                if (left <= 0) {
                    clearInterval(timer);
                    this.closeResultPanel();
                }
            }, 1000);
            
            btnBack.onclick = () => {
                clearInterval(timer);
                this.closeResultPanel();
            };
        };
        
        Game.prototype.closeResultPanel = function() {
            const panel = document.getElementById('result-panel');
            panel.style.display = 'none';
            document.getElementById('lobby-panel').style.display = '';
            document.getElementById('status-label').style.display = 'none';
            
            // 退出比赛模式，恢复UI
            document.getElementById('game-container').classList.remove('racing-mode');
            if (this && typeof this.preloadNextScene === 'function') this.preloadNextScene();
        };
    </script>
</body>
</html>
